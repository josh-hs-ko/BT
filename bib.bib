%% This BibTeX bibliography file was created using BibDesk.
%% https://bibdesk.sourceforge.io/

%% Created for Josh Ko at 2024-02-17 21:01:12 +0800 


%% Saved with string encoding Unicode (UTF-8) 



@article{Van-Muylder-internal-parametricity,
	abstract = {Two approaches exist to incorporate parametricity into proof assistants based on dependent type theory. On the one hand, parametricity translations conveniently compute parametricity statements and their proofs solely based on individual well-typed polymorphic programs. But they do not offer internal parametricity: formal proofs that any polymorphic program of a certain type satisfies its parametricity statement. On the other hand, internally parametric type theories augment plain type theory with additional primitives out of which internal parametricity can be derived. But those type theories lack mature proof assistant implementations and deriving parametricity in them involves low-level intractable proofs. In this paper, we contribute \textsf{Agda --bridges}: the first practical internally parametric proof assistant. We provide the first mechanized proofs of crucial theorems for internal parametricity, like the relativity theorem. We identify a high-level sufficient condition for proving internal parametricity which we call the structure relatedness principle (SRP) by analogy with the structure identity principle (SIP) of HoTT/UF. We state and prove a general parametricity theorem for types that satisfy the SRP. Our parametricity theorem lets us obtain one-liner proofs of standard internal free theorems. We observe that the SRP is harder to prove than the SIP and provide in \textsf{Agda --bridges} a shallowly embedded type theory to compose types that satisfy the SRP. This type theory is an observational type theory of logical relations and our parametricity theorem ought to be one of its inference rules.},
	author = {Van Muylder, Antoine and Nuyts, Andreas and Devriese, Dominique},
	date-added = {2024-02-02 23:14:26 +0800},
	date-modified = {2024-02-02 23:18:21 +0800},
	doi = {10.1145/3632850},
	journal = {Proceedings of the ACM on Programming Languages},
	number = {POPL},
	pages = {8:1--32},
	title = {Internal and Observational Parametricity for {Cubical Agda}},
	volume = {8},
	year = {2024},
	bdsk-file-1 = {YnBsaXN0MDDSAQIDBFxyZWxhdGl2ZVBhdGhZYWxpYXNEYXRhXxCxLi4vLi4vTGlicmFyeS9Nb2JpbGUgRG9jdW1lbnRzL0pGSldXUDY0UUR+Y29tfmdvb2Rpd2FyZX5Hb29kUmVhZGVyL0RvY3VtZW50cy9CaWJSZXBvc2l0b3J5L1ZhbiBNdXlsZGVyIGV0IGFsIDIwMjQgLSBJbnRlcm5hbCBhbmQgT2JzZXJ2YXRpb25hbCBQYXJhbWV0cmljaXR5IGZvciBDdWJpY2FsIEFnZGEucGRmTxEDAgAAAAADAgACAAAMTWFjaW50b3NoIEhEAAAAAAAAAAAAAAAAAAAA4eNFI0JEAAH/////H1ZhbiBNdXlsZGVyIGV0IGFsICNGRkZGRkZGRi5wZGYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAP/////h4ybLAAAAAAAAAAAAAgAGAAAKIGN1AAAAAAAAAAAAAAAAAA1CaWJSZXBvc2l0b3J5AAACALovOlVzZXJzOmpvc2hrbzpMaWJyYXJ5Ok1vYmlsZSBEb2N1bWVudHM6SkZKV1dQNjRRRH5jb21+Z29vZGl3YXJlfkdvb2RSZWFkZXI6RG9jdW1lbnRzOkJpYlJlcG9zaXRvcnk6VmFuIE11eWxkZXIgZXQgYWwgMjAyNCAtIEludGVybmFsIGFuZCBPYnNlcnZhdGlvbmFsIFBhcmFtZXRyaWNpdHkgZm9yIEN1YmljYWwgQWdkYS5wZGYADgCuAFYAVgBhAG4AIABNAHUAeQBsAGQAZQByACAAZQB0ACAAYQBsACAAMgAwADIANAAgAC0AIABJAG4AdABlAHIAbgBhAGwAIABhAG4AZAAgAE8AYgBzAGUAcgB2AGEAdABpAG8AbgBhAGwAIABQAGEAcgBhAG0AZQB0AHIAaQBjAGkAdAB5ACAAZgBvAHIAIABDAHUAYgBpAGMAYQBsACAAQQBnAGQAYQAuAHAAZABmAA8AGgAMAE0AYQBjAGkAbgB0AG8AcwBoACAASABEABIAuFVzZXJzL2pvc2hrby9MaWJyYXJ5L01vYmlsZSBEb2N1bWVudHMvSkZKV1dQNjRRRH5jb21+Z29vZGl3YXJlfkdvb2RSZWFkZXIvRG9jdW1lbnRzL0JpYlJlcG9zaXRvcnkvVmFuIE11eWxkZXIgZXQgYWwgMjAyNCAtIEludGVybmFsIGFuZCBPYnNlcnZhdGlvbmFsIFBhcmFtZXRyaWNpdHkgZm9yIEN1YmljYWwgQWdkYS5wZGYAEwABLwAAFQACAA3//wAAAAgADQAaACQA2AAAAAAAAAIBAAAAAAAAAAUAAAAAAAAAAAAAAAAAAAPe}}

@misc{Mu-sublists,
	abstract = {Some top-down problem specifications, if executed, may compute sub-problems repeatedly. Instead, we may want a bottom-up algorithm that stores solutions of sub-problems in a table to be reused. How the table can be represented and efficiently maintained, however, can be tricky. We study a special case: computing a function $h$ taking lists as inputs such that $h\;\mathit{xs}$ is defined in terms of all immediate sublists of $\mathit{xs}$. Richard Bird studied this problem in 2008, and presented a concise but cryptic algorithm without much explanation. We give this algorithm a proper derivation, and discovered a key property that allows it to work. The algorithm builds trees that have certain shapes -- the sizes along the left spine is a diagonal in Pascal's triangle. The crucial function we derive transforms one diagonal to the next.},
	author = {Mu, Shin-Cheng},
	date-added = {2023-12-29 15:17:40 +0800},
	date-modified = {2023-12-29 15:19:17 +0800},
	doi = {10.48550/arXiv.2311.18528},
	title = {Bottom-Up Computation Using Trees of Sublists (Functional Pearl)},
	year = {2023},
	bdsk-file-1 = {YnBsaXN0MDDSAQIDBFxyZWxhdGl2ZVBhdGhZYWxpYXNEYXRhXxCqLi4vLi4vTGlicmFyeS9Nb2JpbGUgRG9jdW1lbnRzL0pGSldXUDY0UUR+Y29tfmdvb2Rpd2FyZX5Hb29kUmVhZGVyL0RvY3VtZW50cy9CaWJSZXBvc2l0b3J5L011IDIwMjMgLSBCb3R0b20tVXAgQ29tcHV0YXRpb24gVXNpbmcgVHJlZXMgb2YgU3VibGlzdHMgKEZ1bmN0aW9uYWwgUGVhcmwpYS5wZGZPEQLoAAAAAALoAAIAAAxNYWNpbnRvc2ggSEQAAAAAAAAAAAAAAAAAAADh40UjQkQAAf////8fTXUgMjAyMyAtIEJvdHRvbS1VI0ZGRkZGRkZGLnBkZgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA/////+G0k9cAAAAAAAAAAAACAAYAAAogY3UAAAAAAAAAAAAAAAAADUJpYlJlcG9zaXRvcnkAAAIAsy86VXNlcnM6am9zaGtvOkxpYnJhcnk6TW9iaWxlIERvY3VtZW50czpKRkpXV1A2NFFEfmNvbX5nb29kaXdhcmV+R29vZFJlYWRlcjpEb2N1bWVudHM6QmliUmVwb3NpdG9yeTpNdSAyMDIzIC0gQm90dG9tLVVwIENvbXB1dGF0aW9uIFVzaW5nIFRyZWVzIG9mIFN1Ymxpc3RzIChGdW5jdGlvbmFsIFBlYXJsKWEucGRmAAAOAKAATwBNAHUAIAAyADAAMgAzACAALQAgAEIAbwB0AHQAbwBtAC0AVQBwACAAQwBvAG0AcAB1AHQAYQB0AGkAbwBuACAAVQBzAGkAbgBnACAAVAByAGUAZQBzACAAbwBmACAAUwB1AGIAbABpAHMAdABzACAAKABGAHUAbgBjAHQAaQBvAG4AYQBsACAAUABlAGEAcgBsACkAYQAuAHAAZABmAA8AGgAMAE0AYQBjAGkAbgB0AG8AcwBoACAASABEABIAsVVzZXJzL2pvc2hrby9MaWJyYXJ5L01vYmlsZSBEb2N1bWVudHMvSkZKV1dQNjRRRH5jb21+Z29vZGl3YXJlfkdvb2RSZWFkZXIvRG9jdW1lbnRzL0JpYlJlcG9zaXRvcnkvTXUgMjAyMyAtIEJvdHRvbS1VcCBDb21wdXRhdGlvbiBVc2luZyBUcmVlcyBvZiBTdWJsaXN0cyAoRnVuY3Rpb25hbCBQZWFybClhLnBkZgAAEwABLwAAFQACAA3//wAAAAgADQAaACQA0QAAAAAAAAIBAAAAAAAAAAUAAAAAAAAAAAAAAAAAAAO9}}

@book{Hinze-string-diagrams,
	author = {Hinze, Ralf and Marsden, Dan},
	date-added = {2023-12-08 14:33:24 +0800},
	date-modified = {2023-12-08 14:33:45 +0800},
	doi = {10.1017/9781009317825},
	isbn = {9781009317863},
	publisher = {Cambridge University Press},
	title = {Introducing String Diagrams: The Art of Category Theory},
	year = {2023},
	bdsk-url-1 = {https://doi.org/10.1017/9781009317825}}

@book{Coecke-PQP,
	author = {Coecke, Bob and Kissinger, Aleks},
	date-added = {2020-11-19 23:49:43 +0800},
	date-modified = {2020-11-19 23:51:09 +0800},
	doi = {10.1017/9781316219317},
	isbn = {9781107104228},
	publisher = {Cambridge University Press},
	title = {Picturing Quantum Processes},
	year = {2017},
	bdsk-file-1 = {YnBsaXN0MDDSAQIDBFxyZWxhdGl2ZVBhdGhZYWxpYXNEYXRhXxCOLi4vLi4vTGlicmFyeS9Nb2JpbGUgRG9jdW1lbnRzL0pGSldXUDY0UUR+Y29tfmdvb2Rpd2FyZX5Hb29kUmVhZGVyL0RvY3VtZW50cy9CaWJSZXBvc2l0b3J5L0NvZWNrZSBldCBhbCAyMDE3IC0gUGljdHVyaW5nIFF1YW50dW0gUHJvY2Vzc2VzLnBkZk8RAngAAAAAAngAAgAADE1hY2ludG9zaCBIRAAAAAAAAAAAAAAAAAAAAOHjRSNCRAAB/////x9Db2Vja2UgZXQgYWwgMjAxNyAjRkZGRkZGRkYucGRmAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD/////29y0bQAAAAAAAAAAAAIABgAACiBjdQAAAAAAAAAAAAAAAAANQmliUmVwb3NpdG9yeQAAAgCXLzpVc2Vyczpqb3Noa286TGlicmFyeTpNb2JpbGUgRG9jdW1lbnRzOkpGSldXUDY0UUR+Y29tfmdvb2Rpd2FyZX5Hb29kUmVhZGVyOkRvY3VtZW50czpCaWJSZXBvc2l0b3J5OkNvZWNrZSBldCBhbCAyMDE3IC0gUGljdHVyaW5nIFF1YW50dW0gUHJvY2Vzc2VzLnBkZgAADgBoADMAQwBvAGUAYwBrAGUAIABlAHQAIABhAGwAIAAyADAAMQA3ACAALQAgAFAAaQBjAHQAdQByAGkAbgBnACAAUQB1AGEAbgB0AHUAbQAgAFAAcgBvAGMAZQBzAHMAZQBzAC4AcABkAGYADwAaAAwATQBhAGMAaQBuAHQAbwBzAGgAIABIAEQAEgCVVXNlcnMvam9zaGtvL0xpYnJhcnkvTW9iaWxlIERvY3VtZW50cy9KRkpXV1A2NFFEfmNvbX5nb29kaXdhcmV+R29vZFJlYWRlci9Eb2N1bWVudHMvQmliUmVwb3NpdG9yeS9Db2Vja2UgZXQgYWwgMjAxNyAtIFBpY3R1cmluZyBRdWFudHVtIFByb2Nlc3Nlcy5wZGYAABMAAS8AABUAAgAN//8AAAAIAA0AGgAkALUAAAAAAAACAQAAAAAAAAAFAAAAAAAAAAAAAAAAAAADMQ==},
	bdsk-url-1 = {https://doi.org/10.1017/9781316219317}}

@article{Dagand-functional-ornaments,
	abstract = {Programming with dependent types is a blessing and a curse. It is a blessing to be able to bake invariants into the definition of datatypes: We can finally write correct-by-construction software. However, this extreme accuracy is also a curse: A datatype is the combination of a structuring medium together with a special purpose logic. These domain-specific logics hamper any attempt to reuse code across similarly structured data. In this paper, we capitalise on the structural invariants of datatypes. To do so, we first adapt the notion of ornament to our universe of inductive families. We then show how code reuse can be achieved by ornamenting functions. Using these functional ornaments, we capture the relationship between functions such as the addition of natural numbers and the concatenation of lists. With this knowledge, we demonstrate how the implementation of the former informs the implementation of the latter: The users can ask the definition of addition to be lifted to lists and they will only be asked the details necessary to carry on adding lists rather than numbers. Our presentation is formalised in the type theory with a universe of datatypes and all our constructions have been implemented as generic programs, requiring no extension to the type theory.},
	author = {Dagand, Pierre-{\'E}variste and McBride, Conor},
	date-added = {2011-12-14 12:01:28 +0000},
	date-modified = {2015-07-08 02:45:06 +0000},
	doi = {10.1017/S0956796814000069},
	journal = {Journal of Functional Programming},
	number = {2--3},
	pages = {316-383},
	read = {1},
	title = {Transporting Functions across Ornaments},
	volume = {24},
	year = {2014},
	bdsk-file-1 = {YnBsaXN0MDDSAQIDBFxyZWxhdGl2ZVBhdGhZYWxpYXNEYXRhXxCaLi4vLi4vTGlicmFyeS9Nb2JpbGUgRG9jdW1lbnRzL0pGSldXUDY0UUR+Y29tfmdvb2Rpd2FyZX5Hb29kUmVhZGVyL0RvY3VtZW50cy9CaWJSZXBvc2l0b3J5L0RhZ2FuZCBldCBhbCAyMDE0IC0gVHJhbnNwb3J0aW5nIEZ1bmN0aW9ucyBhY3Jvc3MgT3JuYW1lbnRzLnBkZk8RAqgAAAAAAqgAAgAADE1hY2ludG9zaCBIRAAAAAAAAAAAAAAAAAAAAOHjRSNCRAAB/////x9EYWdhbmQgZXQgYWwgMjAxNCAjRkZGRkZGRkYucGRmAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD/////1GGxmAAAAAAAAAAAAAIABgAACiBjdQAAAAAAAAAAAAAAAAANQmliUmVwb3NpdG9yeQAAAgCjLzpVc2Vyczpqb3Noa286TGlicmFyeTpNb2JpbGUgRG9jdW1lbnRzOkpGSldXUDY0UUR+Y29tfmdvb2Rpd2FyZX5Hb29kUmVhZGVyOkRvY3VtZW50czpCaWJSZXBvc2l0b3J5OkRhZ2FuZCBldCBhbCAyMDE0IC0gVHJhbnNwb3J0aW5nIEZ1bmN0aW9ucyBhY3Jvc3MgT3JuYW1lbnRzLnBkZgAADgCAAD8ARABhAGcAYQBuAGQAIABlAHQAIABhAGwAIAAyADAAMQA0ACAALQAgAFQAcgBhAG4AcwBwAG8AcgB0AGkAbgBnACAARgB1AG4AYwB0AGkAbwBuAHMAIABhAGMAcgBvAHMAcwAgAE8AcgBuAGEAbQBlAG4AdABzAC4AcABkAGYADwAaAAwATQBhAGMAaQBuAHQAbwBzAGgAIABIAEQAEgChVXNlcnMvam9zaGtvL0xpYnJhcnkvTW9iaWxlIERvY3VtZW50cy9KRkpXV1A2NFFEfmNvbX5nb29kaXdhcmV+R29vZFJlYWRlci9Eb2N1bWVudHMvQmliUmVwb3NpdG9yeS9EYWdhbmQgZXQgYWwgMjAxNCAtIFRyYW5zcG9ydGluZyBGdW5jdGlvbnMgYWNyb3NzIE9ybmFtZW50cy5wZGYAABMAAS8AABUAAgAN//8AAAAIAA0AGgAkAMEAAAAAAAACAQAAAAAAAAAFAAAAAAAAAAAAAAAAAAADbQ==},
	bdsk-url-1 = {https://doi.org/10.1017/S0956796814000069}}

@book{UFP-HoTT,
	author = {{The Univalent Foundations Program}},
	date-added = {2013-06-20 21:22:57 +0000},
	date-modified = {2023-02-20 13:28:01 +0800},
	publisher = {Institute for Advanced Study},
	title = {Homotopy Type Theory: Univalent Foundations of Mathematics},
	url = {https://homotopytypetheory.org/book/},
	year = {2013},
	bdsk-file-1 = {YnBsaXN0MDDSAQIDBFxyZWxhdGl2ZVBhdGhZYWxpYXNEYXRhXxDBLi4vLi4vTGlicmFyeS9Nb2JpbGUgRG9jdW1lbnRzL0pGSldXUDY0UUR+Y29tfmdvb2Rpd2FyZX5Hb29kUmVhZGVyL0RvY3VtZW50cy9CaWJSZXBvc2l0b3J5L1RoZSBVbml2YWxlbnQgRm91bmRhdGlvbnMgUHJvZ3JhbSAyMDEzIC0gSG9tb3RvcHkgVHlwZSBUaGVvcnkgVW5pdmFsZW50IEZvdW5kYXRpb25zIG9mIE1hdGhlbWF0aWNzLnBkZk8RA0IAAAAAA0IAAgAADE1hY2ludG9zaCBIRAAAAAAAAAAAAAAAAAAAAOHjRSNCRAAB/////x9UaGUgVW5pdmFsZW50IEZvdW4jRkZGRkZGRkYucGRmAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD/////03nVfQAAAAAAAAAAAAIABgAACiBjdQAAAAAAAAAAAAAAAAANQmliUmVwb3NpdG9yeQAAAgDKLzpVc2Vyczpqb3Noa286TGlicmFyeTpNb2JpbGUgRG9jdW1lbnRzOkpGSldXUDY0UUR+Y29tfmdvb2Rpd2FyZX5Hb29kUmVhZGVyOkRvY3VtZW50czpCaWJSZXBvc2l0b3J5OlRoZSBVbml2YWxlbnQgRm91bmRhdGlvbnMgUHJvZ3JhbSAyMDEzIC0gSG9tb3RvcHkgVHlwZSBUaGVvcnkgVW5pdmFsZW50IEZvdW5kYXRpb25zIG9mIE1hdGhlbWF0aWNzLnBkZgAOAM4AZgBUAGgAZQAgAFUAbgBpAHYAYQBsAGUAbgB0ACAARgBvAHUAbgBkAGEAdABpAG8AbgBzACAAUAByAG8AZwByAGEAbQAgADIAMAAxADMAIAAtACAASABvAG0AbwB0AG8AcAB5ACAAVAB5AHAAZQAgAFQAaABlAG8AcgB5ACAAVQBuAGkAdgBhAGwAZQBuAHQAIABGAG8AdQBuAGQAYQB0AGkAbwBuAHMAIABvAGYAIABNAGEAdABoAGUAbQBhAHQAaQBjAHMALgBwAGQAZgAPABoADABNAGEAYwBpAG4AdABvAHMAaAAgAEgARAASAMhVc2Vycy9qb3Noa28vTGlicmFyeS9Nb2JpbGUgRG9jdW1lbnRzL0pGSldXUDY0UUR+Y29tfmdvb2Rpd2FyZX5Hb29kUmVhZGVyL0RvY3VtZW50cy9CaWJSZXBvc2l0b3J5L1RoZSBVbml2YWxlbnQgRm91bmRhdGlvbnMgUHJvZ3JhbSAyMDEzIC0gSG9tb3RvcHkgVHlwZSBUaGVvcnkgVW5pdmFsZW50IEZvdW5kYXRpb25zIG9mIE1hdGhlbWF0aWNzLnBkZgATAAEvAAAVAAIADf//AAAACAANABoAJADoAAAAAAAAAgEAAAAAAAAABQAAAAAAAAAAAAAAAAAABC4=},
	bdsk-url-1 = {https://homotopytypetheory.org/book/}}

@article{Ko-pcOrn,
	abstract = {Dependently typed programmers are encouraged to use inductive families to integrate constraints with data construction. Different constraints are used in different contexts, leading to different versions of datatypes for the same data structure. For example, sequences might be constrained by length or by an ordering on elements, giving rise to different datatypes ``vectors'' and ``sorted lists'' for the same underlying data structure of sequences. Modular implementation of common operations for these structurally similar datatypes has been a longstanding problem. We propose a datatype-generic solution, in which we axiomatise a family of isomorphisms between datatypes and their more refined versions as datatype refinements, and show that McBride's ornaments can be translated into such refinements. With the ornament-induced refinements, relevant properties of the operations can be separately proven for each constraint, and after the programmer selects several constraints to impose on a basic datatype and synthesises a new datatype incorporating those constraints, the operations can be routinely upgraded to work with the synthesised datatype.
},
	author = {Ko, Hsiang-Shang and Gibbons, Jeremy},
	date-added = {2012-06-14 08:21:18 +0000},
	date-modified = {2022-01-20 15:58:22 +0800},
	doi = {10.2201/NiiPi.2013.10.5},
	journal = {Progress in Informatics},
	pages = {65-88},
	read = {1},
	title = {Modularising Inductive Families},
	volume = {10},
	year = {2013},
	bdsk-file-1 = {YnBsaXN0MDDSAQIDBFxyZWxhdGl2ZVBhdGhZYWxpYXNEYXRhXxCOLi4vLi4vTGlicmFyeS9Nb2JpbGUgRG9jdW1lbnRzL0pGSldXUDY0UUR+Y29tfmdvb2Rpd2FyZX5Hb29kUmVhZGVyL0RvY3VtZW50cy9CaWJSZXBvc2l0b3J5L0tvIGV0IGFsIDIwMTMgLSBNb2R1bGFyaXNpbmcgaW5kdWN0aXZlIGZhbWlsaWVzLnBkZk8RAngAAAAAAngAAgAADE1hY2ludG9zaCBIRAAAAAAAAAAAAAAAAAAAAOHjRSNCRAAB/////x9LbyBldCBhbCAyMDEzIC0gTW8jRkZGRkZGRkYucGRmAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD/////zQIk4QAAAAAAAAAAAAIABgAACiBjdQAAAAAAAAAAAAAAAAANQmliUmVwb3NpdG9yeQAAAgCXLzpVc2Vyczpqb3Noa286TGlicmFyeTpNb2JpbGUgRG9jdW1lbnRzOkpGSldXUDY0UUR+Y29tfmdvb2Rpd2FyZX5Hb29kUmVhZGVyOkRvY3VtZW50czpCaWJSZXBvc2l0b3J5OktvIGV0IGFsIDIwMTMgLSBNb2R1bGFyaXNpbmcgaW5kdWN0aXZlIGZhbWlsaWVzLnBkZgAADgBoADMASwBvACAAZQB0ACAAYQBsACAAMgAwADEAMwAgAC0AIABNAG8AZAB1AGwAYQByAGkAcwBpAG4AZwAgAGkAbgBkAHUAYwB0AGkAdgBlACAAZgBhAG0AaQBsAGkAZQBzAC4AcABkAGYADwAaAAwATQBhAGMAaQBuAHQAbwBzAGgAIABIAEQAEgCVVXNlcnMvam9zaGtvL0xpYnJhcnkvTW9iaWxlIERvY3VtZW50cy9KRkpXV1A2NFFEfmNvbX5nb29kaXdhcmV+R29vZFJlYWRlci9Eb2N1bWVudHMvQmliUmVwb3NpdG9yeS9LbyBldCBhbCAyMDEzIC0gTW9kdWxhcmlzaW5nIGluZHVjdGl2ZSBmYW1pbGllcy5wZGYAABMAAS8AABUAAgAN//8AAAAIAA0AGgAkALUAAAAAAAACAQAAAAAAAAAFAAAAAAAAAAAAAAAAAAADMQ==},
	bdsk-file-2 = {YnBsaXN0MDDSAQIDBFxyZWxhdGl2ZVBhdGhZYWxpYXNEYXRhXxCPLi4vLi4vTGlicmFyeS9Nb2JpbGUgRG9jdW1lbnRzL0pGSldXUDY0UUR+Y29tfmdvb2Rpd2FyZX5Hb29kUmVhZGVyL0RvY3VtZW50cy9CaWJSZXBvc2l0b3J5L0tvIGV0IGFsIDIwMTMgLSBNb2R1bGFyaXNpbmcgaW5kdWN0aXZlIGZhbWlsaWVzYS5wZGZPEQJ6AAAAAAJ6AAIAAAxNYWNpbnRvc2ggSEQAAAAAAAAAAAAAAAAAAADh40UjQkQAAf////8fS28gZXQgYWwgMjAxMyAtIE1vI0ZGRkZGRkZGLnBkZgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA/////93FN9QAAAAAAAAAAAACAAYAAAogY3UAAAAAAAAAAAAAAAAADUJpYlJlcG9zaXRvcnkAAAIAmC86VXNlcnM6am9zaGtvOkxpYnJhcnk6TW9iaWxlIERvY3VtZW50czpKRkpXV1A2NFFEfmNvbX5nb29kaXdhcmV+R29vZFJlYWRlcjpEb2N1bWVudHM6QmliUmVwb3NpdG9yeTpLbyBldCBhbCAyMDEzIC0gTW9kdWxhcmlzaW5nIGluZHVjdGl2ZSBmYW1pbGllc2EucGRmAA4AagA0AEsAbwAgAGUAdAAgAGEAbAAgADIAMAAxADMAIAAtACAATQBvAGQAdQBsAGEAcgBpAHMAaQBuAGcAIABpAG4AZAB1AGMAdABpAHYAZQAgAGYAYQBtAGkAbABpAGUAcwBhAC4AcABkAGYADwAaAAwATQBhAGMAaQBuAHQAbwBzAGgAIABIAEQAEgCWVXNlcnMvam9zaGtvL0xpYnJhcnkvTW9iaWxlIERvY3VtZW50cy9KRkpXV1A2NFFEfmNvbX5nb29kaXdhcmV+R29vZFJlYWRlci9Eb2N1bWVudHMvQmliUmVwb3NpdG9yeS9LbyBldCBhbCAyMDEzIC0gTW9kdWxhcmlzaW5nIGluZHVjdGl2ZSBmYW1pbGllc2EucGRmABMAAS8AABUAAgAN//8AAAAIAA0AGgAkALYAAAAAAAACAQAAAAAAAAAFAAAAAAAAAAAAAAAAAAADNA==},
	bdsk-url-1 = {https://doi.org/10.2201/NiiPi.2013.10.5}}

@article{Bernardy-proofs-for-free,
	abstract = {Reynolds' abstraction theorem (Reynolds, J. C. (1983) Types, abstraction and parametric polymorphism, Inf. Process. 83(1), 513--523) shows how a typing judgement in System F can be translated into a relational statement (in second-order predicate logic) about inhabitants of the type. We obtain a similar result for pure type systems (PTSs): for any PTS used as a programming language, there is a PTS that can be used as a logic for parametricity. Types in the source PTS are translated to relations (expressed as types) in the target. Similarly, values of a given type are translated to proofs that the values satisfy the relational interpretation. We extend the result to inductive families. We also show that the assumption that every term satisfies the parametricity condition generated by its type is consistent with the generated logic.},
	author = {Bernardy, Jean-Philippe and Jansson, Patrik and Paterson, Ross},
	date-added = {2014-02-12 19:20:10 +0000},
	date-modified = {2021-09-03 22:23:10 +0800},
	doi = {10.1017/S0956796812000056},
	journal = {Journal of Functional Programming},
	number = {2},
	pages = {107-152},
	title = {Proofs for Free: Parametricity for Dependent Types},
	volume = {22},
	year = {2012},
	bdsk-file-1 = {YnBsaXN0MDDSAQIDBFxyZWxhdGl2ZVBhdGhZYWxpYXNEYXRhXxCmLi4vLi4vTGlicmFyeS9Nb2JpbGUgRG9jdW1lbnRzL0pGSldXUDY0UUR+Y29tfmdvb2Rpd2FyZX5Hb29kUmVhZGVyL0RvY3VtZW50cy9CaWJSZXBvc2l0b3J5L0Jlcm5hcmR5IGV0IGFsIDIwMTIgLSBQcm9vZnMgZm9yIGZyZWUgUGFyYW1ldHJpY2l0eSBmb3IgZGVwZW5kZW50IHR5cGVzLnBkZk8RAtgAAAAAAtgAAgAADE1hY2ludG9zaCBIRAAAAAAAAAAAAAAAAAAAAOHjRSNCRAAB/////x9CZXJuYXJkeSBldCBhbCAyMDEjRkZGRkZGRkYucGRmAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD/////zyHqVQAAAAAAAAAAAAIABgAACiBjdQAAAAAAAAAAAAAAAAANQmliUmVwb3NpdG9yeQAAAgCvLzpVc2Vyczpqb3Noa286TGlicmFyeTpNb2JpbGUgRG9jdW1lbnRzOkpGSldXUDY0UUR+Y29tfmdvb2Rpd2FyZX5Hb29kUmVhZGVyOkRvY3VtZW50czpCaWJSZXBvc2l0b3J5OkJlcm5hcmR5IGV0IGFsIDIwMTIgLSBQcm9vZnMgZm9yIGZyZWUgUGFyYW1ldHJpY2l0eSBmb3IgZGVwZW5kZW50IHR5cGVzLnBkZgAADgCYAEsAQgBlAHIAbgBhAHIAZAB5ACAAZQB0ACAAYQBsACAAMgAwADEAMgAgAC0AIABQAHIAbwBvAGYAcwAgAGYAbwByACAAZgByAGUAZQAgAFAAYQByAGEAbQBlAHQAcgBpAGMAaQB0AHkAIABmAG8AcgAgAGQAZQBwAGUAbgBkAGUAbgB0ACAAdAB5AHAAZQBzAC4AcABkAGYADwAaAAwATQBhAGMAaQBuAHQAbwBzAGgAIABIAEQAEgCtVXNlcnMvam9zaGtvL0xpYnJhcnkvTW9iaWxlIERvY3VtZW50cy9KRkpXV1A2NFFEfmNvbX5nb29kaXdhcmV+R29vZFJlYWRlci9Eb2N1bWVudHMvQmliUmVwb3NpdG9yeS9CZXJuYXJkeSBldCBhbCAyMDEyIC0gUHJvb2ZzIGZvciBmcmVlIFBhcmFtZXRyaWNpdHkgZm9yIGRlcGVuZGVudCB0eXBlcy5wZGYAABMAAS8AABUAAgAN//8AAAAIAA0AGgAkAM0AAAAAAAACAQAAAAAAAAAFAAAAAAAAAAAAAAAAAAADqQ==},
	bdsk-url-1 = {https://doi.org/10.1017/S0956796812000056}}

@inproceedings{Chapman-levitation,
	abstract = {We present a closed dependent type theory whose inductive types are given not by a scheme for generative declarations, but by encoding in a \emph{universe}. Each inductive datatype arises by interpreting its \emph{description}---a first-class value in a datatype of descriptions. Moreover, the latter itself has a description. Datatype-generic programming thus becomes ordinary programming. We show some of the resulting generic operations and deploy them in particular, useful ways on the datatype of datatype descriptions itself. Simulations in existing systems suggest that this apparently self-supporting setup is achievable without paradox or infinite regress.},
	author = {Chapman, James and Dagand, Pierre-{\'E}variste and McBride, Conor and Morris, Peter},
	booktitle = {International Conference on Functional Programming (ICFP)},
	date-added = {2011-04-20 15:31:09 +0100},
	date-modified = {2015-12-09 02:41:29 +0000},
	doi = {10.1145/1863543.1863547},
	pages = {3-14},
	publisher = {ACM},
	read = {1},
	title = {The Gentle Art of Levitation},
	year = {2010},
	bdsk-file-1 = {YnBsaXN0MDDSAQIDBFxyZWxhdGl2ZVBhdGhZYWxpYXNEYXRhXxCQLi4vLi4vTGlicmFyeS9Nb2JpbGUgRG9jdW1lbnRzL0pGSldXUDY0UUR+Y29tfmdvb2Rpd2FyZX5Hb29kUmVhZGVyL0RvY3VtZW50cy9CaWJSZXBvc2l0b3J5L0NoYXBtYW4gZXQgYWwgMjAxMCAtIFRoZSBHZW50bGUgQXJ0IG9mIExldml0YXRpb24ucGRmTxECgAAAAAACgAACAAAMTWFjaW50b3NoIEhEAAAAAAAAAAAAAAAAAAAA4eNFI0JEAAH/////H0NoYXBtYW4gZXQgYWwgMjAxMCNGRkZGRkZGRi5wZGYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAP/////JFcikAAAAAAAAAAAAAgAGAAAKIGN1AAAAAAAAAAAAAAAAAA1CaWJSZXBvc2l0b3J5AAACAJkvOlVzZXJzOmpvc2hrbzpMaWJyYXJ5Ok1vYmlsZSBEb2N1bWVudHM6SkZKV1dQNjRRRH5jb21+Z29vZGl3YXJlfkdvb2RSZWFkZXI6RG9jdW1lbnRzOkJpYlJlcG9zaXRvcnk6Q2hhcG1hbiBldCBhbCAyMDEwIC0gVGhlIEdlbnRsZSBBcnQgb2YgTGV2aXRhdGlvbi5wZGYAAA4AbAA1AEMAaABhAHAAbQBhAG4AIABlAHQAIABhAGwAIAAyADAAMQAwACAALQAgAFQAaABlACAARwBlAG4AdABsAGUAIABBAHIAdAAgAG8AZgAgAEwAZQB2AGkAdABhAHQAaQBvAG4ALgBwAGQAZgAPABoADABNAGEAYwBpAG4AdABvAHMAaAAgAEgARAASAJdVc2Vycy9qb3Noa28vTGlicmFyeS9Nb2JpbGUgRG9jdW1lbnRzL0pGSldXUDY0UUR+Y29tfmdvb2Rpd2FyZX5Hb29kUmVhZGVyL0RvY3VtZW50cy9CaWJSZXBvc2l0b3J5L0NoYXBtYW4gZXQgYWwgMjAxMCAtIFRoZSBHZW50bGUgQXJ0IG9mIExldml0YXRpb24ucGRmAAATAAEvAAAVAAIADf//AAAACAANABoAJAC3AAAAAAAAAgEAAAAAAAAABQAAAAAAAAAAAAAAAAAAAzs=},
	bdsk-url-1 = {https://doi.org/10.1145/1863543.1863547}}

@inproceedings{Voigtlander-BX-for-free,
	abstract = {A bidirectional transformation consists of a function $\mathit{get}$ that takes a source (document or value) to a view and a function $\mathit{put}$ that takes an updated view and the original source back to an updated source, governed by certain consistency conditions relating the two functions. Both the database and programming language communities have studied techniques that essentially allow a user to specify only one of $\mathit{get}$ and $\mathit{put}$ and have the other inferred automatically. All approaches so far to this bidirectionalization task have been syntactic in nature, either proposing a domain-specific language with limited expressiveness but built-in (and composable) backward components, or restricting $\mathit{get}$ to a simple syntactic form from which some algorithm can synthesize an appropriate definition for $\mathit{put}$. Here we present a semantic approach instead. The idea is to take a general-purpose language, Haskell, and write a higher-order function that takes (polymorphic) $\mathit{get}$-functions as arguments and returns appropriate $\mathit{put}$-functions. All this on the level of semantic values, without being willing, or even able, to inspect the definition of $\mathit{get}$, and thus liberated from syntactic restraints. Our solution is inspired by relational parametricity and uses free theorems for proving the consistency conditions. It works beautifully.},
	author = {Voigtl{\"a}nder, Janis},
	booktitle = {Symposium on Principles of Programming Languages (POPL)},
	date-added = {2015-04-08 05:49:23 +0000},
	date-modified = {2015-12-07 00:46:46 +0000},
	doi = {10.1145/1480881.1480904},
	pages = {165-176},
	publisher = {ACM},
	title = {Bidirectionalization for Free!},
	year = {2009},
	bdsk-file-1 = {YnBsaXN0MDDSAQIDBFxyZWxhdGl2ZVBhdGhZYWxpYXNEYXRhbxCSAC4ALgAvAC4ALgAvAEwAaQBiAHIAYQByAHkALwBNAG8AYgBpAGwAZQAgAEQAbwBjAHUAbQBlAG4AdABzAC8ASgBGAEoAVwBXAFAANgA0AFEARAB+AGMAbwBtAH4AZwBvAG8AZABpAHcAYQByAGUAfgBHAG8AbwBkAFIAZQBhAGQAZQByAC8ARABvAGMAdQBtAGUAbgB0AHMALwBCAGkAYgBSAGUAcABvAHMAaQB0AG8AcgB5AC8AVgBvAGkAZwB0AGwAYQMIAG4AZABlAHIAIAAyADAAMAA5ACAALQAgAEIAaQBkAGkAcgBlAGMAdABpAG8AbgBhAGwAaQB6AGEAdABpAG8AbgAgAGYAbwByACAARgByAGUAZQAhAGEALgBwAGQAZk8RAogAAAAAAogAAgAADE1hY2ludG9zaCBIRAAAAAAAAAAAAAAAAAAAAOHjRSNCRAAB/////x9Wb2lndKFabmRlciAyMDA5IC0jRkZGRkZGRkYucGRmAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD/////0aS99AAAAAAAAAAAAAIABgAACiBjdQAAAAAAAAAAAAAAAAANQmliUmVwb3NpdG9yeQAAAgCcLzpVc2Vyczpqb3Noa286TGlicmFyeTpNb2JpbGUgRG9jdW1lbnRzOkpGSldXUDY0UUR+Y29tfmdvb2Rpd2FyZX5Hb29kUmVhZGVyOkRvY3VtZW50czpCaWJSZXBvc2l0b3J5OlZvaWd0bGHMiG5kZXIgMjAwOSAtIEJpZGlyZWN0aW9uYWxpemF0aW9uIGZvciBGcmVlIWEucGRmAA4AcAA3AFYAbwBpAGcAdABsAGEDCABuAGQAZQByACAAMgAwADAAOQAgAC0AIABCAGkAZABpAHIAZQBjAHQAaQBvAG4AYQBsAGkAegBhAHQAaQBvAG4AIABmAG8AcgAgAEYAcgBlAGUAIQBhAC4AcABkAGYADwAaAAwATQBhAGMAaQBuAHQAbwBzAGgAIABIAEQAEgCaVXNlcnMvam9zaGtvL0xpYnJhcnkvTW9iaWxlIERvY3VtZW50cy9KRkpXV1A2NFFEfmNvbX5nb29kaXdhcmV+R29vZFJlYWRlci9Eb2N1bWVudHMvQmliUmVwb3NpdG9yeS9Wb2lndGxhzIhuZGVyIDIwMDkgLSBCaWRpcmVjdGlvbmFsaXphdGlvbiBmb3IgRnJlZSFhLnBkZgATAAEvAAAVAAIADf//AAAACAANABoAJAFLAAAAAAAAAgEAAAAAAAAABQAAAAAAAAAAAAAAAAAAA9c=},
	bdsk-url-1 = {https://doi.org/10.1145/1480881.1480904}}

@inproceedings{Bird-zippy-tabulations,
	abstract = {This paper is devoted to the statement and proof of a theorem showing how recursive definitions whose associated call graphs satisfy certain shape conditions can be converted systematically into efficient bottom-up tabulation schemes. The increase in efficiency can be dramatic, typically transforming an exponential time algorithm into one that takes only quadratic time. The proof of the theorem relies heavily on the theory of zips developed by Roland Backhouse and Paul Hoogendijk.},
	author = {Bird, Richard S.},
	booktitle = {International Conference on Mathematics of Program Construction (MPC)},
	date-added = {2022-06-02 20:52:56 +0800},
	date-modified = {2022-06-02 20:54:08 +0800},
	doi = {10.1007/978-3-540-70594-9_7},
	pages = {92--109},
	publisher = {Springer},
	series = {Lecture Notes in Computer Science},
	title = {Zippy Tabulations of Recursive Functions},
	volume = {5133},
	year = {2008},
	bdsk-file-1 = {YnBsaXN0MDDSAQIDBFxyZWxhdGl2ZVBhdGhZYWxpYXNEYXRhXxCTLi4vLi4vTGlicmFyeS9Nb2JpbGUgRG9jdW1lbnRzL0pGSldXUDY0UUR+Y29tfmdvb2Rpd2FyZX5Hb29kUmVhZGVyL0RvY3VtZW50cy9CaWJSZXBvc2l0b3J5L0JpcmQgMjAwOCAtIFppcHB5IFRhYnVsYXRpb25zIG9mIFJlY3Vyc2l2ZSBGdW5jdGlvbnMucGRmTxECigAAAAACigACAAAMTWFjaW50b3NoIEhEAAAAAAAAAAAAAAAAAAAA4eNFI0JEAAH/////H0JpcmQgMjAwOCAtIFppcHB5ICNGRkZGRkZGRi5wZGYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAP/////evtPmAAAAAAAAAAAAAgAGAAAKIGN1AAAAAAAAAAAAAAAAAA1CaWJSZXBvc2l0b3J5AAACAJwvOlVzZXJzOmpvc2hrbzpMaWJyYXJ5Ok1vYmlsZSBEb2N1bWVudHM6SkZKV1dQNjRRRH5jb21+Z29vZGl3YXJlfkdvb2RSZWFkZXI6RG9jdW1lbnRzOkJpYlJlcG9zaXRvcnk6QmlyZCAyMDA4IC0gWmlwcHkgVGFidWxhdGlvbnMgb2YgUmVjdXJzaXZlIEZ1bmN0aW9ucy5wZGYADgByADgAQgBpAHIAZAAgADIAMAAwADgAIAAtACAAWgBpAHAAcAB5ACAAVABhAGIAdQBsAGEAdABpAG8AbgBzACAAbwBmACAAUgBlAGMAdQByAHMAaQB2AGUAIABGAHUAbgBjAHQAaQBvAG4AcwAuAHAAZABmAA8AGgAMAE0AYQBjAGkAbgB0AG8AcwBoACAASABEABIAmlVzZXJzL2pvc2hrby9MaWJyYXJ5L01vYmlsZSBEb2N1bWVudHMvSkZKV1dQNjRRRH5jb21+Z29vZGl3YXJlfkdvb2RSZWFkZXIvRG9jdW1lbnRzL0JpYlJlcG9zaXRvcnkvQmlyZCAyMDA4IC0gWmlwcHkgVGFidWxhdGlvbnMgb2YgUmVjdXJzaXZlIEZ1bmN0aW9ucy5wZGYAEwABLwAAFQACAA3//wAAAAgADQAaACQAugAAAAAAAAIBAAAAAAAAAAUAAAAAAAAAAAAAAAAAAANI},
	bdsk-url-1 = {https://doi.org/10.1007/978-3-540-70594-9_7}}

@article{Dybjer-inductive-families,
	abstract = {A general formulation of inductive and recursive definitions in Martin-L{\"o}f's type theory is presented. It extends Backhouse's `Do-It-Yourself Type Theory' to include inductive definitions of families of sets and definitions of functions by recursion on the way elements of such sets are generated. The formulation is in natural deduction and is intended to be a natural generalisation to type theory of Martin-L{\"o}f's theory of iterated inductive definitions in predicate logic.\par

Formal criteria are given for correct formation and introduction rules of a new set former capturing definition by strictly positive, iterated, generalised induction. Moreover, there is an inversion principle for deriving elimination and equality rules from the formation and introduction rules. Finally, there is an alternative schematic presentation of definition by recursion.\par

The resulting theory is a flexible and powerful language for programming and constructive mathematics. We hint at the wealth of possible applications by showing several basic examples: predicate logic, generalised induction, and a formalisation of the untyped lambda calculus.},
	author = {Peter Dybjer},
	date-added = {2011-05-04 10:12:27 +0100},
	date-modified = {2019-05-13 22:52:07 +0900},
	doi = {10.1007/BF01211308},
	journal = {Formal Aspects of Computing},
	number = {4},
	pages = {440-465},
	title = {Inductive Families},
	volume = 6,
	year = 1994,
	bdsk-file-1 = {YnBsaXN0MDDSAQIDBFxyZWxhdGl2ZVBhdGhZYWxpYXNEYXRhXxB/Li4vLi4vTGlicmFyeS9Nb2JpbGUgRG9jdW1lbnRzL0pGSldXUDY0UUR+Y29tfmdvb2Rpd2FyZX5Hb29kUmVhZGVyL0RvY3VtZW50cy9CaWJSZXBvc2l0b3J5L0R5YmplciAxOTk0IC0gSW5kdWN0aXZlIEZhbWlsaWVzLnBkZk8RAjoAAAAAAjoAAgAADE1hY2ludG9zaCBIRAAAAAAAAAAAAAAAAAAAAOHjRSNCRAAB/////x9EeWJqZXIgMTk5NCAtIEluZHUjRkZGRkZGRkYucGRmAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD/////yec5aAAAAAAAAAAAAAIABgAACiBjdQAAAAAAAAAAAAAAAAANQmliUmVwb3NpdG9yeQAAAgCILzpVc2Vyczpqb3Noa286TGlicmFyeTpNb2JpbGUgRG9jdW1lbnRzOkpGSldXUDY0UUR+Y29tfmdvb2Rpd2FyZX5Hb29kUmVhZGVyOkRvY3VtZW50czpCaWJSZXBvc2l0b3J5OkR5YmplciAxOTk0IC0gSW5kdWN0aXZlIEZhbWlsaWVzLnBkZgAOAEoAJABEAHkAYgBqAGUAcgAgADEAOQA5ADQAIAAtACAASQBuAGQAdQBjAHQAaQB2AGUAIABGAGEAbQBpAGwAaQBlAHMALgBwAGQAZgAPABoADABNAGEAYwBpAG4AdABvAHMAaAAgAEgARAASAIZVc2Vycy9qb3Noa28vTGlicmFyeS9Nb2JpbGUgRG9jdW1lbnRzL0pGSldXUDY0UUR+Y29tfmdvb2Rpd2FyZX5Hb29kUmVhZGVyL0RvY3VtZW50cy9CaWJSZXBvc2l0b3J5L0R5YmplciAxOTk0IC0gSW5kdWN0aXZlIEZhbWlsaWVzLnBkZgATAAEvAAAVAAIADf//AAAACAANABoAJACmAAAAAAAAAgEAAAAAAAAABQAAAAAAAAAAAAAAAAAAAuQ=},
	bdsk-url-1 = {https://doi.org/10.1007/BF01211308}}

@inproceedings{Bird&Hinze-nexus,
author = {Bird, Richard and Hinze, Ralf},
title = {Trouble Shared Is Trouble Halved},
year = {2003},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
doi = {10.1145/871895.871896},
abstract = {A nexus is a tree that contains shared nodes, nodes that have more than one incoming arc. Shared nodes are created in almost every functional program---for instance, when updating a purely functional data structure---though programmers are seldom aware of this. In fact, there are only a few algorithms that exploit sharing of nodes consciously. One example is constructing a tree in sublinear time. In this pearl we discuss an intriguing application of nexuses; we show that they serve admirably as memo structures featuring constant time access to memoized function calls. Along the way we encounter Boolean lattices and binomial trees.},
booktitle = {ACM SIGPLAN Workshop on Haskell},
pages = {1–6},
}