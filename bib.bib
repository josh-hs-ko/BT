%% This BibTeX bibliography file was created using BibDesk.
%% https://bibdesk.sourceforge.io/

%% Created for Josh Ko at 2024-02-08 00:39:24 +0800 


%% Saved with string encoding Unicode (UTF-8) 



@misc{Mu-sublists,
	abstract = {Some top-down problem specifications, if executed, may compute sub-problems repeatedly. Instead, we may want a bottom-up algorithm that stores solutions of sub-problems in a table to be reused. How the table can be represented and efficiently maintained, however, can be tricky. We study a special case: computing a function $h$ taking lists as inputs such that $h\;\mathit{xs}$ is defined in terms of all immediate sublists of $\mathit{xs}$. Richard Bird studied this problem in 2008, and presented a concise but cryptic algorithm without much explanation. We give this algorithm a proper derivation, and discovered a key property that allows it to work. The algorithm builds trees that have certain shapes -- the sizes along the left spine is a diagonal in Pascal's triangle. The crucial function we derive transforms one diagonal to the next.},
	author = {Mu, Shin-Cheng},
	date-added = {2023-12-29 15:17:40 +0800},
	date-modified = {2023-12-29 15:19:17 +0800},
	doi = {10.48550/arXiv.2311.18528},
	title = {Bottom-Up Computation Using Trees of Sublists (Functional Pearl)},
	year = {2023},
	bdsk-file-1 = {YnBsaXN0MDDSAQIDBFxyZWxhdGl2ZVBhdGhZYWxpYXNEYXRhXxCqLi4vLi4vTGlicmFyeS9Nb2JpbGUgRG9jdW1lbnRzL0pGSldXUDY0UUR+Y29tfmdvb2Rpd2FyZX5Hb29kUmVhZGVyL0RvY3VtZW50cy9CaWJSZXBvc2l0b3J5L011IDIwMjMgLSBCb3R0b20tVXAgQ29tcHV0YXRpb24gVXNpbmcgVHJlZXMgb2YgU3VibGlzdHMgKEZ1bmN0aW9uYWwgUGVhcmwpYS5wZGZPEQLoAAAAAALoAAIAAAxNYWNpbnRvc2ggSEQAAAAAAAAAAAAAAAAAAADhxwkMQkQAAf////8fTXUgMjAyMyAtIEJvdHRvbS1VI0ZGRkZGRkZGLnBkZgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA/////+G0k9cAAAAAAAAAAAACAAYAAAogY3UAAAAAAAAAAAAAAAAADUJpYlJlcG9zaXRvcnkAAAIAsy86VXNlcnM6am9zaGtvOkxpYnJhcnk6TW9iaWxlIERvY3VtZW50czpKRkpXV1A2NFFEfmNvbX5nb29kaXdhcmV+R29vZFJlYWRlcjpEb2N1bWVudHM6QmliUmVwb3NpdG9yeTpNdSAyMDIzIC0gQm90dG9tLVVwIENvbXB1dGF0aW9uIFVzaW5nIFRyZWVzIG9mIFN1Ymxpc3RzIChGdW5jdGlvbmFsIFBlYXJsKWEucGRmAAAOAKAATwBNAHUAIAAyADAAMgAzACAALQAgAEIAbwB0AHQAbwBtAC0AVQBwACAAQwBvAG0AcAB1AHQAYQB0AGkAbwBuACAAVQBzAGkAbgBnACAAVAByAGUAZQBzACAAbwBmACAAUwB1AGIAbABpAHMAdABzACAAKABGAHUAbgBjAHQAaQBvAG4AYQBsACAAUABlAGEAcgBsACkAYQAuAHAAZABmAA8AGgAMAE0AYQBjAGkAbgB0AG8AcwBoACAASABEABIAsVVzZXJzL2pvc2hrby9MaWJyYXJ5L01vYmlsZSBEb2N1bWVudHMvSkZKV1dQNjRRRH5jb21+Z29vZGl3YXJlfkdvb2RSZWFkZXIvRG9jdW1lbnRzL0JpYlJlcG9zaXRvcnkvTXUgMjAyMyAtIEJvdHRvbS1VcCBDb21wdXRhdGlvbiBVc2luZyBUcmVlcyBvZiBTdWJsaXN0cyAoRnVuY3Rpb25hbCBQZWFybClhLnBkZgAAEwABLwAAFQACAA3//wAAAAgADQAaACQA0QAAAAAAAAIBAAAAAAAAAAUAAAAAAAAAAAAAAAAAAAO9}}

@book{Coecke-PQP,
	author = {Coecke, Bob and Kissinger, Aleks},
	date-added = {2020-11-19 23:49:43 +0800},
	date-modified = {2020-11-19 23:51:09 +0800},
	doi = {10.1017/9781316219317},
	isbn = {9781107104228},
	publisher = {Cambridge University Press},
	title = {Picturing Quantum Processes},
	year = {2017},
	bdsk-file-1 = {YnBsaXN0MDDSAQIDBFxyZWxhdGl2ZVBhdGhZYWxpYXNEYXRhXxCOLi4vLi4vTGlicmFyeS9Nb2JpbGUgRG9jdW1lbnRzL0pGSldXUDY0UUR+Y29tfmdvb2Rpd2FyZX5Hb29kUmVhZGVyL0RvY3VtZW50cy9CaWJSZXBvc2l0b3J5L0NvZWNrZSBldCBhbCAyMDE3IC0gUGljdHVyaW5nIFF1YW50dW0gUHJvY2Vzc2VzLnBkZk8RAngAAAAAAngAAgAADE1hY2ludG9zaCBIRAAAAAAAAAAAAAAAAAAAAOHHCQxCRAAB/////x9Db2Vja2UgZXQgYWwgMjAxNyAjRkZGRkZGRkYucGRmAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD/////29y0bQAAAAAAAAAAAAIABgAACiBjdQAAAAAAAAAAAAAAAAANQmliUmVwb3NpdG9yeQAAAgCXLzpVc2Vyczpqb3Noa286TGlicmFyeTpNb2JpbGUgRG9jdW1lbnRzOkpGSldXUDY0UUR+Y29tfmdvb2Rpd2FyZX5Hb29kUmVhZGVyOkRvY3VtZW50czpCaWJSZXBvc2l0b3J5OkNvZWNrZSBldCBhbCAyMDE3IC0gUGljdHVyaW5nIFF1YW50dW0gUHJvY2Vzc2VzLnBkZgAADgBoADMAQwBvAGUAYwBrAGUAIABlAHQAIABhAGwAIAAyADAAMQA3ACAALQAgAFAAaQBjAHQAdQByAGkAbgBnACAAUQB1AGEAbgB0AHUAbQAgAFAAcgBvAGMAZQBzAHMAZQBzAC4AcABkAGYADwAaAAwATQBhAGMAaQBuAHQAbwBzAGgAIABIAEQAEgCVVXNlcnMvam9zaGtvL0xpYnJhcnkvTW9iaWxlIERvY3VtZW50cy9KRkpXV1A2NFFEfmNvbX5nb29kaXdhcmV+R29vZFJlYWRlci9Eb2N1bWVudHMvQmliUmVwb3NpdG9yeS9Db2Vja2UgZXQgYWwgMjAxNyAtIFBpY3R1cmluZyBRdWFudHVtIFByb2Nlc3Nlcy5wZGYAABMAAS8AABUAAgAN//8AAAAIAA0AGgAkALUAAAAAAAACAQAAAAAAAAAFAAAAAAAAAAAAAAAAAAADMQ==},
	bdsk-url-1 = {https://doi.org/10.1017/9781316219317}}

@article{Dagand-functional-ornaments,
	abstract = {Programming with dependent types is a blessing and a curse. It is a blessing to be able to bake invariants into the definition of datatypes: We can finally write correct-by-construction software. However, this extreme accuracy is also a curse: A datatype is the combination of a structuring medium together with a special purpose logic. These domain-specific logics hamper any attempt to reuse code across similarly structured data. In this paper, we capitalise on the structural invariants of datatypes. To do so, we first adapt the notion of ornament to our universe of inductive families. We then show how code reuse can be achieved by ornamenting functions. Using these functional ornaments, we capture the relationship between functions such as the addition of natural numbers and the concatenation of lists. With this knowledge, we demonstrate how the implementation of the former informs the implementation of the latter: The users can ask the definition of addition to be lifted to lists and they will only be asked the details necessary to carry on adding lists rather than numbers. Our presentation is formalised in the type theory with a universe of datatypes and all our constructions have been implemented as generic programs, requiring no extension to the type theory.},
	author = {Dagand, Pierre-{\'E}variste and McBride, Conor},
	date-added = {2011-12-14 12:01:28 +0000},
	date-modified = {2015-07-08 02:45:06 +0000},
	doi = {10.1017/S0956796814000069},
	journal = {Journal of Functional Programming},
	number = {2--3},
	pages = {316-383},
	read = {1},
	title = {Transporting Functions across Ornaments},
	volume = {24},
	year = {2014},
	bdsk-file-1 = {YnBsaXN0MDDSAQIDBFxyZWxhdGl2ZVBhdGhZYWxpYXNEYXRhXxCaLi4vLi4vTGlicmFyeS9Nb2JpbGUgRG9jdW1lbnRzL0pGSldXUDY0UUR+Y29tfmdvb2Rpd2FyZX5Hb29kUmVhZGVyL0RvY3VtZW50cy9CaWJSZXBvc2l0b3J5L0RhZ2FuZCBldCBhbCAyMDE0IC0gVHJhbnNwb3J0aW5nIEZ1bmN0aW9ucyBhY3Jvc3MgT3JuYW1lbnRzLnBkZk8RAqgAAAAAAqgAAgAADE1hY2ludG9zaCBIRAAAAAAAAAAAAAAAAAAAAOHHCQxCRAAB/////x9EYWdhbmQgZXQgYWwgMjAxNCAjRkZGRkZGRkYucGRmAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD/////1GGxmAAAAAAAAAAAAAIABgAACiBjdQAAAAAAAAAAAAAAAAANQmliUmVwb3NpdG9yeQAAAgCjLzpVc2Vyczpqb3Noa286TGlicmFyeTpNb2JpbGUgRG9jdW1lbnRzOkpGSldXUDY0UUR+Y29tfmdvb2Rpd2FyZX5Hb29kUmVhZGVyOkRvY3VtZW50czpCaWJSZXBvc2l0b3J5OkRhZ2FuZCBldCBhbCAyMDE0IC0gVHJhbnNwb3J0aW5nIEZ1bmN0aW9ucyBhY3Jvc3MgT3JuYW1lbnRzLnBkZgAADgCAAD8ARABhAGcAYQBuAGQAIABlAHQAIABhAGwAIAAyADAAMQA0ACAALQAgAFQAcgBhAG4AcwBwAG8AcgB0AGkAbgBnACAARgB1AG4AYwB0AGkAbwBuAHMAIABhAGMAcgBvAHMAcwAgAE8AcgBuAGEAbQBlAG4AdABzAC4AcABkAGYADwAaAAwATQBhAGMAaQBuAHQAbwBzAGgAIABIAEQAEgChVXNlcnMvam9zaGtvL0xpYnJhcnkvTW9iaWxlIERvY3VtZW50cy9KRkpXV1A2NFFEfmNvbX5nb29kaXdhcmV+R29vZFJlYWRlci9Eb2N1bWVudHMvQmliUmVwb3NpdG9yeS9EYWdhbmQgZXQgYWwgMjAxNCAtIFRyYW5zcG9ydGluZyBGdW5jdGlvbnMgYWNyb3NzIE9ybmFtZW50cy5wZGYAABMAAS8AABUAAgAN//8AAAAIAA0AGgAkAMEAAAAAAAACAQAAAAAAAAAFAAAAAAAAAAAAAAAAAAADbQ==},
	bdsk-url-1 = {https://doi.org/10.1017/S0956796814000069}}

@article{Ko-pcOrn,
	abstract = {Dependently typed programmers are encouraged to use inductive families to integrate constraints with data construction. Different constraints are used in different contexts, leading to different versions of datatypes for the same data structure. For example, sequences might be constrained by length or by an ordering on elements, giving rise to different datatypes ``vectors'' and ``sorted lists'' for the same underlying data structure of sequences. Modular implementation of common operations for these structurally similar datatypes has been a longstanding problem. We propose a datatype-generic solution, in which we axiomatise a family of isomorphisms between datatypes and their more refined versions as datatype refinements, and show that McBride's ornaments can be translated into such refinements. With the ornament-induced refinements, relevant properties of the operations can be separately proven for each constraint, and after the programmer selects several constraints to impose on a basic datatype and synthesises a new datatype incorporating those constraints, the operations can be routinely upgraded to work with the synthesised datatype.
},
	author = {Ko, Hsiang-Shang and Gibbons, Jeremy},
	date-added = {2012-06-14 08:21:18 +0000},
	date-modified = {2022-01-20 15:58:22 +0800},
	doi = {10.2201/NiiPi.2013.10.5},
	journal = {Progress in Informatics},
	pages = {65-88},
	read = {1},
	title = {Modularising Inductive Families},
	volume = {10},
	year = {2013},
	bdsk-file-1 = {YnBsaXN0MDDSAQIDBFxyZWxhdGl2ZVBhdGhZYWxpYXNEYXRhXxCOLi4vLi4vTGlicmFyeS9Nb2JpbGUgRG9jdW1lbnRzL0pGSldXUDY0UUR+Y29tfmdvb2Rpd2FyZX5Hb29kUmVhZGVyL0RvY3VtZW50cy9CaWJSZXBvc2l0b3J5L0tvIGV0IGFsIDIwMTMgLSBNb2R1bGFyaXNpbmcgaW5kdWN0aXZlIGZhbWlsaWVzLnBkZk8RAngAAAAAAngAAgAADE1hY2ludG9zaCBIRAAAAAAAAAAAAAAAAAAAAOHHCQxCRAAB/////x9LbyBldCBhbCAyMDEzIC0gTW8jRkZGRkZGRkYucGRmAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD/////zQIk4QAAAAAAAAAAAAIABgAACiBjdQAAAAAAAAAAAAAAAAANQmliUmVwb3NpdG9yeQAAAgCXLzpVc2Vyczpqb3Noa286TGlicmFyeTpNb2JpbGUgRG9jdW1lbnRzOkpGSldXUDY0UUR+Y29tfmdvb2Rpd2FyZX5Hb29kUmVhZGVyOkRvY3VtZW50czpCaWJSZXBvc2l0b3J5OktvIGV0IGFsIDIwMTMgLSBNb2R1bGFyaXNpbmcgaW5kdWN0aXZlIGZhbWlsaWVzLnBkZgAADgBoADMASwBvACAAZQB0ACAAYQBsACAAMgAwADEAMwAgAC0AIABNAG8AZAB1AGwAYQByAGkAcwBpAG4AZwAgAGkAbgBkAHUAYwB0AGkAdgBlACAAZgBhAG0AaQBsAGkAZQBzAC4AcABkAGYADwAaAAwATQBhAGMAaQBuAHQAbwBzAGgAIABIAEQAEgCVVXNlcnMvam9zaGtvL0xpYnJhcnkvTW9iaWxlIERvY3VtZW50cy9KRkpXV1A2NFFEfmNvbX5nb29kaXdhcmV+R29vZFJlYWRlci9Eb2N1bWVudHMvQmliUmVwb3NpdG9yeS9LbyBldCBhbCAyMDEzIC0gTW9kdWxhcmlzaW5nIGluZHVjdGl2ZSBmYW1pbGllcy5wZGYAABMAAS8AABUAAgAN//8AAAAIAA0AGgAkALUAAAAAAAACAQAAAAAAAAAFAAAAAAAAAAAAAAAAAAADMQ==},
	bdsk-file-2 = {YnBsaXN0MDDSAQIDBFxyZWxhdGl2ZVBhdGhZYWxpYXNEYXRhXxCPLi4vLi4vTGlicmFyeS9Nb2JpbGUgRG9jdW1lbnRzL0pGSldXUDY0UUR+Y29tfmdvb2Rpd2FyZX5Hb29kUmVhZGVyL0RvY3VtZW50cy9CaWJSZXBvc2l0b3J5L0tvIGV0IGFsIDIwMTMgLSBNb2R1bGFyaXNpbmcgaW5kdWN0aXZlIGZhbWlsaWVzYS5wZGZPEQJ6AAAAAAJ6AAIAAAxNYWNpbnRvc2ggSEQAAAAAAAAAAAAAAAAAAADhxwkMQkQAAf////8fS28gZXQgYWwgMjAxMyAtIE1vI0ZGRkZGRkZGLnBkZgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA/////93FN9QAAAAAAAAAAAACAAYAAAogY3UAAAAAAAAAAAAAAAAADUJpYlJlcG9zaXRvcnkAAAIAmC86VXNlcnM6am9zaGtvOkxpYnJhcnk6TW9iaWxlIERvY3VtZW50czpKRkpXV1A2NFFEfmNvbX5nb29kaXdhcmV+R29vZFJlYWRlcjpEb2N1bWVudHM6QmliUmVwb3NpdG9yeTpLbyBldCBhbCAyMDEzIC0gTW9kdWxhcmlzaW5nIGluZHVjdGl2ZSBmYW1pbGllc2EucGRmAA4AagA0AEsAbwAgAGUAdAAgAGEAbAAgADIAMAAxADMAIAAtACAATQBvAGQAdQBsAGEAcgBpAHMAaQBuAGcAIABpAG4AZAB1AGMAdABpAHYAZQAgAGYAYQBtAGkAbABpAGUAcwBhAC4AcABkAGYADwAaAAwATQBhAGMAaQBuAHQAbwBzAGgAIABIAEQAEgCWVXNlcnMvam9zaGtvL0xpYnJhcnkvTW9iaWxlIERvY3VtZW50cy9KRkpXV1A2NFFEfmNvbX5nb29kaXdhcmV+R29vZFJlYWRlci9Eb2N1bWVudHMvQmliUmVwb3NpdG9yeS9LbyBldCBhbCAyMDEzIC0gTW9kdWxhcmlzaW5nIGluZHVjdGl2ZSBmYW1pbGllc2EucGRmABMAAS8AABUAAgAN//8AAAAIAA0AGgAkALYAAAAAAAACAQAAAAAAAAAFAAAAAAAAAAAAAAAAAAADNA==},
	bdsk-url-1 = {https://doi.org/10.2201/NiiPi.2013.10.5}}

@article{Bernardy-proofs-for-free,
	abstract = {Reynolds' abstraction theorem (Reynolds, J. C. (1983) Types, abstraction and parametric polymorphism, Inf. Process. 83(1), 513--523) shows how a typing judgement in System F can be translated into a relational statement (in second-order predicate logic) about inhabitants of the type. We obtain a similar result for pure type systems (PTSs): for any PTS used as a programming language, there is a PTS that can be used as a logic for parametricity. Types in the source PTS are translated to relations (expressed as types) in the target. Similarly, values of a given type are translated to proofs that the values satisfy the relational interpretation. We extend the result to inductive families. We also show that the assumption that every term satisfies the parametricity condition generated by its type is consistent with the generated logic.},
	author = {Bernardy, Jean-Philippe and Jansson, Patrik and Paterson, Ross},
	date-added = {2014-02-12 19:20:10 +0000},
	date-modified = {2021-09-03 22:23:10 +0800},
	doi = {10.1017/S0956796812000056},
	journal = {Journal of Functional Programming},
	number = {2},
	pages = {107-152},
	title = {Proofs for Free: Parametricity for Dependent Types},
	volume = {22},
	year = {2012},
	bdsk-file-1 = {YnBsaXN0MDDSAQIDBFxyZWxhdGl2ZVBhdGhZYWxpYXNEYXRhXxCmLi4vLi4vTGlicmFyeS9Nb2JpbGUgRG9jdW1lbnRzL0pGSldXUDY0UUR+Y29tfmdvb2Rpd2FyZX5Hb29kUmVhZGVyL0RvY3VtZW50cy9CaWJSZXBvc2l0b3J5L0Jlcm5hcmR5IGV0IGFsIDIwMTIgLSBQcm9vZnMgZm9yIGZyZWUgUGFyYW1ldHJpY2l0eSBmb3IgZGVwZW5kZW50IHR5cGVzLnBkZk8RAtgAAAAAAtgAAgAADE1hY2ludG9zaCBIRAAAAAAAAAAAAAAAAAAAAOHHCQxCRAAB/////x9CZXJuYXJkeSBldCBhbCAyMDEjRkZGRkZGRkYucGRmAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD/////zyHqVQAAAAAAAAAAAAIABgAACiBjdQAAAAAAAAAAAAAAAAANQmliUmVwb3NpdG9yeQAAAgCvLzpVc2Vyczpqb3Noa286TGlicmFyeTpNb2JpbGUgRG9jdW1lbnRzOkpGSldXUDY0UUR+Y29tfmdvb2Rpd2FyZX5Hb29kUmVhZGVyOkRvY3VtZW50czpCaWJSZXBvc2l0b3J5OkJlcm5hcmR5IGV0IGFsIDIwMTIgLSBQcm9vZnMgZm9yIGZyZWUgUGFyYW1ldHJpY2l0eSBmb3IgZGVwZW5kZW50IHR5cGVzLnBkZgAADgCYAEsAQgBlAHIAbgBhAHIAZAB5ACAAZQB0ACAAYQBsACAAMgAwADEAMgAgAC0AIABQAHIAbwBvAGYAcwAgAGYAbwByACAAZgByAGUAZQAgAFAAYQByAGEAbQBlAHQAcgBpAGMAaQB0AHkAIABmAG8AcgAgAGQAZQBwAGUAbgBkAGUAbgB0ACAAdAB5AHAAZQBzAC4AcABkAGYADwAaAAwATQBhAGMAaQBuAHQAbwBzAGgAIABIAEQAEgCtVXNlcnMvam9zaGtvL0xpYnJhcnkvTW9iaWxlIERvY3VtZW50cy9KRkpXV1A2NFFEfmNvbX5nb29kaXdhcmV+R29vZFJlYWRlci9Eb2N1bWVudHMvQmliUmVwb3NpdG9yeS9CZXJuYXJkeSBldCBhbCAyMDEyIC0gUHJvb2ZzIGZvciBmcmVlIFBhcmFtZXRyaWNpdHkgZm9yIGRlcGVuZGVudCB0eXBlcy5wZGYAABMAAS8AABUAAgAN//8AAAAIAA0AGgAkAM0AAAAAAAACAQAAAAAAAAAFAAAAAAAAAAAAAAAAAAADqQ==},
	bdsk-url-1 = {https://doi.org/10.1017/S0956796812000056}}

@inproceedings{Chapman-levitation,
	abstract = {We present a closed dependent type theory whose inductive types are given not by a scheme for generative declarations, but by encoding in a \emph{universe}. Each inductive datatype arises by interpreting its \emph{description}---a first-class value in a datatype of descriptions. Moreover, the latter itself has a description. Datatype-generic programming thus becomes ordinary programming. We show some of the resulting generic operations and deploy them in particular, useful ways on the datatype of datatype descriptions itself. Simulations in existing systems suggest that this apparently self-supporting setup is achievable without paradox or infinite regress.},
	author = {Chapman, James and Dagand, Pierre-{\'E}variste and McBride, Conor and Morris, Peter},
	booktitle = {International Conference on Functional Programming (ICFP)},
	date-added = {2011-04-20 15:31:09 +0100},
	date-modified = {2015-12-09 02:41:29 +0000},
	doi = {10.1145/1863543.1863547},
	pages = {3-14},
	publisher = {ACM},
	read = {1},
	title = {The Gentle Art of Levitation},
	year = {2010},
	bdsk-file-1 = {YnBsaXN0MDDSAQIDBFxyZWxhdGl2ZVBhdGhZYWxpYXNEYXRhXxCQLi4vLi4vTGlicmFyeS9Nb2JpbGUgRG9jdW1lbnRzL0pGSldXUDY0UUR+Y29tfmdvb2Rpd2FyZX5Hb29kUmVhZGVyL0RvY3VtZW50cy9CaWJSZXBvc2l0b3J5L0NoYXBtYW4gZXQgYWwgMjAxMCAtIFRoZSBHZW50bGUgQXJ0IG9mIExldml0YXRpb24ucGRmTxECgAAAAAACgAACAAAMTWFjaW50b3NoIEhEAAAAAAAAAAAAAAAAAAAA4ccJDEJEAAH/////H0NoYXBtYW4gZXQgYWwgMjAxMCNGRkZGRkZGRi5wZGYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAP/////JFcikAAAAAAAAAAAAAgAGAAAKIGN1AAAAAAAAAAAAAAAAAA1CaWJSZXBvc2l0b3J5AAACAJkvOlVzZXJzOmpvc2hrbzpMaWJyYXJ5Ok1vYmlsZSBEb2N1bWVudHM6SkZKV1dQNjRRRH5jb21+Z29vZGl3YXJlfkdvb2RSZWFkZXI6RG9jdW1lbnRzOkJpYlJlcG9zaXRvcnk6Q2hhcG1hbiBldCBhbCAyMDEwIC0gVGhlIEdlbnRsZSBBcnQgb2YgTGV2aXRhdGlvbi5wZGYAAA4AbAA1AEMAaABhAHAAbQBhAG4AIABlAHQAIABhAGwAIAAyADAAMQAwACAALQAgAFQAaABlACAARwBlAG4AdABsAGUAIABBAHIAdAAgAG8AZgAgAEwAZQB2AGkAdABhAHQAaQBvAG4ALgBwAGQAZgAPABoADABNAGEAYwBpAG4AdABvAHMAaAAgAEgARAASAJdVc2Vycy9qb3Noa28vTGlicmFyeS9Nb2JpbGUgRG9jdW1lbnRzL0pGSldXUDY0UUR+Y29tfmdvb2Rpd2FyZX5Hb29kUmVhZGVyL0RvY3VtZW50cy9CaWJSZXBvc2l0b3J5L0NoYXBtYW4gZXQgYWwgMjAxMCAtIFRoZSBHZW50bGUgQXJ0IG9mIExldml0YXRpb24ucGRmAAATAAEvAAAVAAIADf//AAAACAANABoAJAC3AAAAAAAAAgEAAAAAAAAABQAAAAAAAAAAAAAAAAAAAzs=},
	bdsk-url-1 = {https://doi.org/10.1145/1863543.1863547}}

@inproceedings{Bird-zippy-tabulations,
	abstract = {This paper is devoted to the statement and proof of a theorem showing how recursive definitions whose associated call graphs satisfy certain shape conditions can be converted systematically into efficient bottom-up tabulation schemes. The increase in efficiency can be dramatic, typically transforming an exponential time algorithm into one that takes only quadratic time. The proof of the theorem relies heavily on the theory of zips developed by Roland Backhouse and Paul Hoogendijk.},
	author = {Bird, Richard S.},
	booktitle = {International Conference on Mathematics of Program Construction (MPC)},
	date-added = {2022-06-02 20:52:56 +0800},
	date-modified = {2022-06-02 20:54:08 +0800},
	doi = {10.1007/978-3-540-70594-9_7},
	pages = {92--109},
	publisher = {Springer},
	series = {Lecture Notes in Computer Science},
	title = {Zippy Tabulations of Recursive Functions},
	volume = {5133},
	year = {2008},
	bdsk-file-1 = {YnBsaXN0MDDSAQIDBFxyZWxhdGl2ZVBhdGhZYWxpYXNEYXRhXxCTLi4vLi4vTGlicmFyeS9Nb2JpbGUgRG9jdW1lbnRzL0pGSldXUDY0UUR+Y29tfmdvb2Rpd2FyZX5Hb29kUmVhZGVyL0RvY3VtZW50cy9CaWJSZXBvc2l0b3J5L0JpcmQgMjAwOCAtIFppcHB5IFRhYnVsYXRpb25zIG9mIFJlY3Vyc2l2ZSBGdW5jdGlvbnMucGRmTxECigAAAAACigACAAAMTWFjaW50b3NoIEhEAAAAAAAAAAAAAAAAAAAA4ccJDEJEAAH/////H0JpcmQgMjAwOCAtIFppcHB5ICNGRkZGRkZGRi5wZGYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAP/////evtPmAAAAAAAAAAAAAgAGAAAKIGN1AAAAAAAAAAAAAAAAAA1CaWJSZXBvc2l0b3J5AAACAJwvOlVzZXJzOmpvc2hrbzpMaWJyYXJ5Ok1vYmlsZSBEb2N1bWVudHM6SkZKV1dQNjRRRH5jb21+Z29vZGl3YXJlfkdvb2RSZWFkZXI6RG9jdW1lbnRzOkJpYlJlcG9zaXRvcnk6QmlyZCAyMDA4IC0gWmlwcHkgVGFidWxhdGlvbnMgb2YgUmVjdXJzaXZlIEZ1bmN0aW9ucy5wZGYADgByADgAQgBpAHIAZAAgADIAMAAwADgAIAAtACAAWgBpAHAAcAB5ACAAVABhAGIAdQBsAGEAdABpAG8AbgBzACAAbwBmACAAUgBlAGMAdQByAHMAaQB2AGUAIABGAHUAbgBjAHQAaQBvAG4AcwAuAHAAZABmAA8AGgAMAE0AYQBjAGkAbgB0AG8AcwBoACAASABEABIAmlVzZXJzL2pvc2hrby9MaWJyYXJ5L01vYmlsZSBEb2N1bWVudHMvSkZKV1dQNjRRRH5jb21+Z29vZGl3YXJlfkdvb2RSZWFkZXIvRG9jdW1lbnRzL0JpYlJlcG9zaXRvcnkvQmlyZCAyMDA4IC0gWmlwcHkgVGFidWxhdGlvbnMgb2YgUmVjdXJzaXZlIEZ1bmN0aW9ucy5wZGYAEwABLwAAFQACAA3//wAAAAgADQAaACQAugAAAAAAAAIBAAAAAAAAAAUAAAAAAAAAAAAAAAAAAANI},
	bdsk-url-1 = {https://doi.org/10.1007/978-3-540-70594-9_7}}
