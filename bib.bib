%% This BibTeX bibliography file was created using BibDesk.
%% http://bibdesk.sourceforge.net/

%% Created for Josh Ko at 2024-01-01 22:06:48 +0800 


%% Saved with string encoding Unicode (UTF-8) 



@misc{Mu-sublists,
	abstract = {Some top-down problem specifications, if executed, may compute sub-problems repeatedly. Instead, we may want a bottom-up algorithm that stores solutions of sub-problems in a table to be reused. How the table can be represented and efficiently maintained, however, can be tricky. We study a special case: computing a function $h$ taking lists as inputs such that $h\;\mathit{xs}$ is defined in terms of all immediate sublists of $\mathit{xs}$. Richard Bird studied this problem in 2008, and presented a concise but cryptic algorithm without much explanation. We give this algorithm a proper derivation, and discovered a key property that allows it to work. The algorithm builds trees that have certain shapes -- the sizes along the left spine is a diagonal in Pascal's triangle. The crucial function we derive transforms one diagonal to the next.},
	author = {Mu, Shin-Cheng},
	date-added = {2023-12-29 15:17:40 +0800},
	date-modified = {2023-12-29 15:19:17 +0800},
	doi = {10.48550/arXiv.2311.18528},
	title = {Bottom-Up Computation Using Trees of Sublists (Functional Pearl)},
	year = {2023},
	bdsk-file-1 = {YnBsaXN0MDDSAQIDBFxyZWxhdGl2ZVBhdGhZYWxpYXNEYXRhXxCqLi4vLi4vTGlicmFyeS9Nb2JpbGUgRG9jdW1lbnRzL0pGSldXUDY0UUR+Y29tfmdvb2Rpd2FyZX5Hb29kUmVhZGVyL0RvY3VtZW50cy9CaWJSZXBvc2l0b3J5L011IDIwMjMgLSBCb3R0b20tVXAgQ29tcHV0YXRpb24gVXNpbmcgVHJlZXMgb2YgU3VibGlzdHMgKEZ1bmN0aW9uYWwgUGVhcmwpYS5wZGZPEQLoAAAAAALoAAIAAAxNYWNpbnRvc2ggSEQAAAAAAAAAAAAAAAAAAADhoocRQkQAAf////8fTXUgMjAyMyAtIEJvdHRvbS1VI0ZGRkZGRkZGLnBkZgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA/////+G0k9cAAAAAAAAAAAACAAYAAAogY3UAAAAAAAAAAAAAAAAADUJpYlJlcG9zaXRvcnkAAAIAsy86VXNlcnM6am9zaGtvOkxpYnJhcnk6TW9iaWxlIERvY3VtZW50czpKRkpXV1A2NFFEfmNvbX5nb29kaXdhcmV+R29vZFJlYWRlcjpEb2N1bWVudHM6QmliUmVwb3NpdG9yeTpNdSAyMDIzIC0gQm90dG9tLVVwIENvbXB1dGF0aW9uIFVzaW5nIFRyZWVzIG9mIFN1Ymxpc3RzIChGdW5jdGlvbmFsIFBlYXJsKWEucGRmAAAOAKAATwBNAHUAIAAyADAAMgAzACAALQAgAEIAbwB0AHQAbwBtAC0AVQBwACAAQwBvAG0AcAB1AHQAYQB0AGkAbwBuACAAVQBzAGkAbgBnACAAVAByAGUAZQBzACAAbwBmACAAUwB1AGIAbABpAHMAdABzACAAKABGAHUAbgBjAHQAaQBvAG4AYQBsACAAUABlAGEAcgBsACkAYQAuAHAAZABmAA8AGgAMAE0AYQBjAGkAbgB0AG8AcwBoACAASABEABIAsVVzZXJzL2pvc2hrby9MaWJyYXJ5L01vYmlsZSBEb2N1bWVudHMvSkZKV1dQNjRRRH5jb21+Z29vZGl3YXJlfkdvb2RSZWFkZXIvRG9jdW1lbnRzL0JpYlJlcG9zaXRvcnkvTXUgMjAyMyAtIEJvdHRvbS1VcCBDb21wdXRhdGlvbiBVc2luZyBUcmVlcyBvZiBTdWJsaXN0cyAoRnVuY3Rpb25hbCBQZWFybClhLnBkZgAAEwABLwAAFQACAA3//wAAAAgADQAaACQA0QAAAAAAAAIBAAAAAAAAAAUAAAAAAAAAAAAAAAAAAAO9}}

@inproceedings{Diehl-InfIR,
	abstract = {The class of Infinitary inductive-recursive (InfIR) types is commonly used to model type theory within itself. While it is common and convenient to provide examples of values within an InfIR model, writing functions that manipulate InfIR types is an underexplored area due to their inherent complexity.\par

Our goal in this work is to push the boundaries of programming with InfIR types by introducing two functions operating over them. The first is a lookup function to extract sub-components from an InfIR type, and the second is an update function to replace sub-components within an InfIR type. We start by considering how to write such functions for concrete examples of InfIR types, and then show how to write generic versions of the functions for any datatype definable in the universe of InfIR types. We actually write two versions of the generic functions, one where the universe is open and another where the universe is closed.},
	author = {Diehl, Larry and Sheard, Tim},
	booktitle = {Workshop on Type-Driven Development (TyDe)},
	date-added = {2022-02-24 10:43:32 +0800},
	date-modified = {2022-02-24 10:44:56 +0800},
	doi = {10.1145/2976022.2976031},
	pages = {1--12},
	publisher = {ACM},
	title = {Generic Lookup and Update for Infinitary Inductive-Recursive Types},
	year = 2016,
	bdsk-file-1 = {YnBsaXN0MDDSAQIDBFxyZWxhdGl2ZVBhdGhZYWxpYXNEYXRhXxC0Li4vLi4vTGlicmFyeS9Nb2JpbGUgRG9jdW1lbnRzL0pGSldXUDY0UUR+Y29tfmdvb2Rpd2FyZX5Hb29kUmVhZGVyL0RvY3VtZW50cy9CaWJSZXBvc2l0b3J5L0RpZWhsIGV0IGFsIDIwMTYgLSBHZW5lcmljIExvb2t1cCBhbmQgVXBkYXRlIGZvciBJbmZpbml0YXJ5IEluZHVjdGl2ZS1SZWN1cnNpdmUgVHlwZXMucGRmTxEDEAAAAAADEAACAAAMTWFjaW50b3NoIEhEAAAAAAAAAAAAAAAAAAAA4aKHEUJEAAH/////H0RpZWhsIGV0IGFsIDIwMTYgLSNGRkZGRkZGRi5wZGYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAP/////ePREXAAAAAAAAAAAAAgAGAAAKIGN1AAAAAAAAAAAAAAAAAA1CaWJSZXBvc2l0b3J5AAACAL0vOlVzZXJzOmpvc2hrbzpMaWJyYXJ5Ok1vYmlsZSBEb2N1bWVudHM6SkZKV1dQNjRRRH5jb21+Z29vZGl3YXJlfkdvb2RSZWFkZXI6RG9jdW1lbnRzOkJpYlJlcG9zaXRvcnk6RGllaGwgZXQgYWwgMjAxNiAtIEdlbmVyaWMgTG9va3VwIGFuZCBVcGRhdGUgZm9yIEluZmluaXRhcnkgSW5kdWN0aXZlLVJlY3Vyc2l2ZSBUeXBlcy5wZGYAAA4AtABZAEQAaQBlAGgAbAAgAGUAdAAgAGEAbAAgADIAMAAxADYAIAAtACAARwBlAG4AZQByAGkAYwAgAEwAbwBvAGsAdQBwACAAYQBuAGQAIABVAHAAZABhAHQAZQAgAGYAbwByACAASQBuAGYAaQBuAGkAdABhAHIAeQAgAEkAbgBkAHUAYwB0AGkAdgBlAC0AUgBlAGMAdQByAHMAaQB2AGUAIABUAHkAcABlAHMALgBwAGQAZgAPABoADABNAGEAYwBpAG4AdABvAHMAaAAgAEgARAASALtVc2Vycy9qb3Noa28vTGlicmFyeS9Nb2JpbGUgRG9jdW1lbnRzL0pGSldXUDY0UUR+Y29tfmdvb2Rpd2FyZX5Hb29kUmVhZGVyL0RvY3VtZW50cy9CaWJSZXBvc2l0b3J5L0RpZWhsIGV0IGFsIDIwMTYgLSBHZW5lcmljIExvb2t1cCBhbmQgVXBkYXRlIGZvciBJbmZpbml0YXJ5IEluZHVjdGl2ZS1SZWN1cnNpdmUgVHlwZXMucGRmAAATAAEvAAAVAAIADf//AAAACAANABoAJADbAAAAAAAAAgEAAAAAAAAABQAAAAAAAAAAAAAAAAAAA+8=},
	bdsk-url-1 = {https://doi.org/10.1145/2976022.2976031}}

@article{Bernardy-proofs-for-free,
	abstract = {Reynolds' abstraction theorem (Reynolds, J. C. (1983) Types, abstraction and parametric polymorphism, Inf. Process. 83(1), 513--523) shows how a typing judgement in System F can be translated into a relational statement (in second-order predicate logic) about inhabitants of the type. We obtain a similar result for pure type systems (PTSs): for any PTS used as a programming language, there is a PTS that can be used as a logic for parametricity. Types in the source PTS are translated to relations (expressed as types) in the target. Similarly, values of a given type are translated to proofs that the values satisfy the relational interpretation. We extend the result to inductive families. We also show that the assumption that every term satisfies the parametricity condition generated by its type is consistent with the generated logic.},
	author = {Bernardy, Jean-Philippe and Jansson, Patrik and Paterson, Ross},
	date-added = {2014-02-12 19:20:10 +0000},
	date-modified = {2021-09-03 22:23:10 +0800},
	doi = {10.1017/S0956796812000056},
	journal = {Journal of Functional Programming},
	number = {2},
	pages = {107-152},
	title = {Proofs for Free: Parametricity for Dependent Types},
	volume = {22},
	year = {2012},
	bdsk-file-1 = {YnBsaXN0MDDSAQIDBFxyZWxhdGl2ZVBhdGhZYWxpYXNEYXRhXxCmLi4vLi4vTGlicmFyeS9Nb2JpbGUgRG9jdW1lbnRzL0pGSldXUDY0UUR+Y29tfmdvb2Rpd2FyZX5Hb29kUmVhZGVyL0RvY3VtZW50cy9CaWJSZXBvc2l0b3J5L0Jlcm5hcmR5IGV0IGFsIDIwMTIgLSBQcm9vZnMgZm9yIGZyZWUgUGFyYW1ldHJpY2l0eSBmb3IgZGVwZW5kZW50IHR5cGVzLnBkZk8RAtgAAAAAAtgAAgAADE1hY2ludG9zaCBIRAAAAAAAAAAAAAAAAAAAAOGihxFCRAAB/////x9CZXJuYXJkeSBldCBhbCAyMDEjRkZGRkZGRkYucGRmAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD/////zyHqVQAAAAAAAAAAAAIABgAACiBjdQAAAAAAAAAAAAAAAAANQmliUmVwb3NpdG9yeQAAAgCvLzpVc2Vyczpqb3Noa286TGlicmFyeTpNb2JpbGUgRG9jdW1lbnRzOkpGSldXUDY0UUR+Y29tfmdvb2Rpd2FyZX5Hb29kUmVhZGVyOkRvY3VtZW50czpCaWJSZXBvc2l0b3J5OkJlcm5hcmR5IGV0IGFsIDIwMTIgLSBQcm9vZnMgZm9yIGZyZWUgUGFyYW1ldHJpY2l0eSBmb3IgZGVwZW5kZW50IHR5cGVzLnBkZgAADgCYAEsAQgBlAHIAbgBhAHIAZAB5ACAAZQB0ACAAYQBsACAAMgAwADEAMgAgAC0AIABQAHIAbwBvAGYAcwAgAGYAbwByACAAZgByAGUAZQAgAFAAYQByAGEAbQBlAHQAcgBpAGMAaQB0AHkAIABmAG8AcgAgAGQAZQBwAGUAbgBkAGUAbgB0ACAAdAB5AHAAZQBzAC4AcABkAGYADwAaAAwATQBhAGMAaQBuAHQAbwBzAGgAIABIAEQAEgCtVXNlcnMvam9zaGtvL0xpYnJhcnkvTW9iaWxlIERvY3VtZW50cy9KRkpXV1A2NFFEfmNvbX5nb29kaXdhcmV+R29vZFJlYWRlci9Eb2N1bWVudHMvQmliUmVwb3NpdG9yeS9CZXJuYXJkeSBldCBhbCAyMDEyIC0gUHJvb2ZzIGZvciBmcmVlIFBhcmFtZXRyaWNpdHkgZm9yIGRlcGVuZGVudCB0eXBlcy5wZGYAABMAAS8AABUAAgAN//8AAAAIAA0AGgAkAM0AAAAAAAACAQAAAAAAAAAFAAAAAAAAAAAAAAAAAAADqQ==},
	bdsk-url-1 = {https://doi.org/10.1017/S0956796812000056}}

@misc{McBride-ornaments,
	abstract = {This paper re-examines the presentation of datatypes in dependently typed languages, addressing in particular the issue of what it means for one datatype to be in various ways more informative than another. Informal human observations like `lists are natural numbers with extra decoration' and `vectors are lists indexed by length' are expressed in a first class language of \emph{ornaments} --- presentations of fancy new types based on plain old ones --- encompassing both decoration and, in the sense of Tim Freeman and Frank Pfenning (1991), refinement.\par

Each ornament adds information, so it comes with a forgetful function from fancy data back to plain, expressible as the fold of its \emph{ornamental algebra}: lists built from numbers acquire the `length' algebra. Conversely, each algebra for a datatype induces a way to index it --- an \emph{algebraic ornament}. The length algebra for lists induces the construction of the paradigmatic dependent vector types.\par

Dependent types thus provide not only a new `axis of diversity' --- indexing --- for data structures, but also new abstractions to manage and exploit that diversity. In the spirit of `the new programming' (McBride \& McKinna, 2004), the engineering of coincidence is replaced by the propagation of consequence.},
	author = {Conor McBride},
	date-added = {2010-12-23 09:24:51 +0000},
	date-modified = {2020-07-28 14:19:24 +0800},
	read = {1},
	title = {Ornamental Algebras, Algebraic Ornaments},
	url = {https://personal.cis.strath.ac.uk/conor.mcbride/pub/OAAO/LitOrn.pdf},
	year = {2011},
	bdsk-file-1 = {YnBsaXN0MDDSAQIDBFxyZWxhdGl2ZVBhdGhZYWxpYXNEYXRhXxCWLi4vLi4vTGlicmFyeS9Nb2JpbGUgRG9jdW1lbnRzL0pGSldXUDY0UUR+Y29tfmdvb2Rpd2FyZX5Hb29kUmVhZGVyL0RvY3VtZW50cy9CaWJSZXBvc2l0b3J5L01jQnJpZGUgMjAxMSAtIE9ybmFtZW50YWwgQWxnZWJyYXMsIEFsZ2VicmFpYyBPcm5hbWVudHMucGRmTxECmAAAAAACmAACAAAMTWFjaW50b3NoIEhEAAAAAAAAAAAAAAAAAAAA4aKHEUJEAAH/////H01jQnJpZGUgMjAxMSAtIE9ybiNGRkZGRkZGRi5wZGYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAP/////JdGxoAAAAAAAAAAAAAgAGAAAKIGN1AAAAAAAAAAAAAAAAAA1CaWJSZXBvc2l0b3J5AAACAJ8vOlVzZXJzOmpvc2hrbzpMaWJyYXJ5Ok1vYmlsZSBEb2N1bWVudHM6SkZKV1dQNjRRRH5jb21+Z29vZGl3YXJlfkdvb2RSZWFkZXI6RG9jdW1lbnRzOkJpYlJlcG9zaXRvcnk6TWNCcmlkZSAyMDExIC0gT3JuYW1lbnRhbCBBbGdlYnJhcywgQWxnZWJyYWljIE9ybmFtZW50cy5wZGYAAA4AeAA7AE0AYwBCAHIAaQBkAGUAIAAyADAAMQAxACAALQAgAE8AcgBuAGEAbQBlAG4AdABhAGwAIABBAGwAZwBlAGIAcgBhAHMALAAgAEEAbABnAGUAYgByAGEAaQBjACAATwByAG4AYQBtAGUAbgB0AHMALgBwAGQAZgAPABoADABNAGEAYwBpAG4AdABvAHMAaAAgAEgARAASAJ1Vc2Vycy9qb3Noa28vTGlicmFyeS9Nb2JpbGUgRG9jdW1lbnRzL0pGSldXUDY0UUR+Y29tfmdvb2Rpd2FyZX5Hb29kUmVhZGVyL0RvY3VtZW50cy9CaWJSZXBvc2l0b3J5L01jQnJpZGUgMjAxMSAtIE9ybmFtZW50YWwgQWxnZWJyYXMsIEFsZ2VicmFpYyBPcm5hbWVudHMucGRmAAATAAEvAAAVAAIADf//AAAACAANABoAJAC9AAAAAAAAAgEAAAAAAAAABQAAAAAAAAAAAAAAAAAAA1k=},
	bdsk-url-1 = {https://personal.cis.strath.ac.uk/conor.mcbride/pub/OAAO/LitOrn.pdf}}

@inproceedings{Voigtlander-BX-for-free,
	abstract = {A bidirectional transformation consists of a function $\mathit{get}$ that takes a source (document or value) to a view and a function $\mathit{put}$ that takes an updated view and the original source back to an updated source, governed by certain consistency conditions relating the two functions. Both the database and programming language communities have studied techniques that essentially allow a user to specify only one of $\mathit{get}$ and $\mathit{put}$ and have the other inferred automatically. All approaches so far to this bidirectionalization task have been syntactic in nature, either proposing a domain-specific language with limited expressiveness but built-in (and composable) backward components, or restricting $\mathit{get}$ to a simple syntactic form from which some algorithm can synthesize an appropriate definition for $\mathit{put}$. Here we present a semantic approach instead. The idea is to take a general-purpose language, Haskell, and write a higher-order function that takes (polymorphic) $\mathit{get}$-functions as arguments and returns appropriate $\mathit{put}$-functions. All this on the level of semantic values, without being willing, or even able, to inspect the definition of $\mathit{get}$, and thus liberated from syntactic restraints. Our solution is inspired by relational parametricity and uses free theorems for proving the consistency conditions. It works beautifully.},
	author = {Voigtl{\"a}nder, Janis},
	booktitle = {Symposium on Principles of Programming Languages (POPL)},
	date-added = {2015-04-08 05:49:23 +0000},
	date-modified = {2015-12-07 00:46:46 +0000},
	doi = {10.1145/1480881.1480904},
	pages = {165-176},
	publisher = {ACM},
	title = {Bidirectionalization for Free!},
	year = {2009},
	bdsk-file-1 = {YnBsaXN0MDDSAQIDBFxyZWxhdGl2ZVBhdGhZYWxpYXNEYXRhbxCSAC4ALgAvAC4ALgAvAEwAaQBiAHIAYQByAHkALwBNAG8AYgBpAGwAZQAgAEQAbwBjAHUAbQBlAG4AdABzAC8ASgBGAEoAVwBXAFAANgA0AFEARAB+AGMAbwBtAH4AZwBvAG8AZABpAHcAYQByAGUAfgBHAG8AbwBkAFIAZQBhAGQAZQByAC8ARABvAGMAdQBtAGUAbgB0AHMALwBCAGkAYgBSAGUAcABvAHMAaQB0AG8AcgB5AC8AVgBvAGkAZwB0AGwAYQMIAG4AZABlAHIAIAAyADAAMAA5ACAALQAgAEIAaQBkAGkAcgBlAGMAdABpAG8AbgBhAGwAaQB6AGEAdABpAG8AbgAgAGYAbwByACAARgByAGUAZQAhAGEALgBwAGQAZk8RAogAAAAAAogAAgAADE1hY2ludG9zaCBIRAAAAAAAAAAAAAAAAAAAAOGihxFCRAAB/////x9Wb2lndKFabmRlciAyMDA5IC0jRkZGRkZGRkYucGRmAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD/////0aS99AAAAAAAAAAAAAIABgAACiBjdQAAAAAAAAAAAAAAAAANQmliUmVwb3NpdG9yeQAAAgCcLzpVc2Vyczpqb3Noa286TGlicmFyeTpNb2JpbGUgRG9jdW1lbnRzOkpGSldXUDY0UUR+Y29tfmdvb2Rpd2FyZX5Hb29kUmVhZGVyOkRvY3VtZW50czpCaWJSZXBvc2l0b3J5OlZvaWd0bGHMiG5kZXIgMjAwOSAtIEJpZGlyZWN0aW9uYWxpemF0aW9uIGZvciBGcmVlIWEucGRmAA4AcAA3AFYAbwBpAGcAdABsAGEDCABuAGQAZQByACAAMgAwADAAOQAgAC0AIABCAGkAZABpAHIAZQBjAHQAaQBvAG4AYQBsAGkAegBhAHQAaQBvAG4AIABmAG8AcgAgAEYAcgBlAGUAIQBhAC4AcABkAGYADwAaAAwATQBhAGMAaQBuAHQAbwBzAGgAIABIAEQAEgCaVXNlcnMvam9zaGtvL0xpYnJhcnkvTW9iaWxlIERvY3VtZW50cy9KRkpXV1A2NFFEfmNvbX5nb29kaXdhcmV+R29vZFJlYWRlci9Eb2N1bWVudHMvQmliUmVwb3NpdG9yeS9Wb2lndGxhzIhuZGVyIDIwMDkgLSBCaWRpcmVjdGlvbmFsaXphdGlvbiBmb3IgRnJlZSFhLnBkZgATAAEvAAAVAAIADf//AAAACAANABoAJAFLAAAAAAAAAgEAAAAAAAAABQAAAAAAAAAAAAAAAAAAA9c=},
	bdsk-url-1 = {https://doi.org/10.1145/1480881.1480904}}

@inproceedings{Bird-zippy-tabulations,
	abstract = {This paper is devoted to the statement and proof of a theorem showing how recursive definitions whose associated call graphs satisfy certain shape conditions can be converted systematically into efficient bottom-up tabulation schemes. The increase in efficiency can be dramatic, typically transforming an exponential time algorithm into one that takes only quadratic time. The proof of the theorem relies heavily on the theory of zips developed by Roland Backhouse and Paul Hoogendijk.},
	author = {Bird, Richard S.},
	booktitle = {International Conference on Mathematics of Program Construction (MPC)},
	date-added = {2022-06-02 20:52:56 +0800},
	date-modified = {2022-06-02 20:54:08 +0800},
	doi = {10.1007/978-3-540-70594-9_7},
	pages = {92--109},
	publisher = {Springer},
	series = {Lecture Notes in Computer Science},
	title = {Zippy Tabulations of Recursive Functions},
	volume = {5133},
	year = {2008},
	bdsk-file-1 = {YnBsaXN0MDDSAQIDBFxyZWxhdGl2ZVBhdGhZYWxpYXNEYXRhXxCTLi4vLi4vTGlicmFyeS9Nb2JpbGUgRG9jdW1lbnRzL0pGSldXUDY0UUR+Y29tfmdvb2Rpd2FyZX5Hb29kUmVhZGVyL0RvY3VtZW50cy9CaWJSZXBvc2l0b3J5L0JpcmQgMjAwOCAtIFppcHB5IFRhYnVsYXRpb25zIG9mIFJlY3Vyc2l2ZSBGdW5jdGlvbnMucGRmTxECigAAAAACigACAAAMTWFjaW50b3NoIEhEAAAAAAAAAAAAAAAAAAAA4aKHEUJEAAH/////H0JpcmQgMjAwOCAtIFppcHB5ICNGRkZGRkZGRi5wZGYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAP/////evtPmAAAAAAAAAAAAAgAGAAAKIGN1AAAAAAAAAAAAAAAAAA1CaWJSZXBvc2l0b3J5AAACAJwvOlVzZXJzOmpvc2hrbzpMaWJyYXJ5Ok1vYmlsZSBEb2N1bWVudHM6SkZKV1dQNjRRRH5jb21+Z29vZGl3YXJlfkdvb2RSZWFkZXI6RG9jdW1lbnRzOkJpYlJlcG9zaXRvcnk6QmlyZCAyMDA4IC0gWmlwcHkgVGFidWxhdGlvbnMgb2YgUmVjdXJzaXZlIEZ1bmN0aW9ucy5wZGYADgByADgAQgBpAHIAZAAgADIAMAAwADgAIAAtACAAWgBpAHAAcAB5ACAAVABhAGIAdQBsAGEAdABpAG8AbgBzACAAbwBmACAAUgBlAGMAdQByAHMAaQB2AGUAIABGAHUAbgBjAHQAaQBvAG4AcwAuAHAAZABmAA8AGgAMAE0AYQBjAGkAbgB0AG8AcwBoACAASABEABIAmlVzZXJzL2pvc2hrby9MaWJyYXJ5L01vYmlsZSBEb2N1bWVudHMvSkZKV1dQNjRRRH5jb21+Z29vZGl3YXJlfkdvb2RSZWFkZXIvRG9jdW1lbnRzL0JpYlJlcG9zaXRvcnkvQmlyZCAyMDA4IC0gWmlwcHkgVGFidWxhdGlvbnMgb2YgUmVjdXJzaXZlIEZ1bmN0aW9ucy5wZGYAEwABLwAAFQACAA3//wAAAAgADQAaACQAugAAAAAAAAIBAAAAAAAAAAUAAAAAAAAAAAAAAAAAAANI},
	bdsk-url-1 = {https://doi.org/10.1007/978-3-540-70594-9_7}}
